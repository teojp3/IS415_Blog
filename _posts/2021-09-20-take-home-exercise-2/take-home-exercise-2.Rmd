---
title: "Take Home Exercise 2"
description: |
  A study on the distribution of Airbnb Listings in Singapore, and how has COVID-19 impacted them.
author:
  - name: Teo Jun Peng
    url: https://teojp3-is415.netlify.app/
date: 09-20-2021
output:
  distill::distill_article:
      self_contained: false
      toc: true
      toc_depth: 2
      toc_float: true
---

```{r setup, include=FALSE, eval=TRUE, echo=TRUE, message=FALSE, error=FALSE, fig.retina=3}
knitr::opts_chunk$set(echo = TRUE, fig.align = "center", tidy.opts=list(width.cutoff=80),tidy=TRUE)
```

# 1. Introduction

Singapore is one of the few countries that does not legalise short-term rentals for properties, a minimum stay of three months is still required for rental of properties as of [2019](https://www.todayonline.com/singapore/short-term-home-sharing-remains-illegal-singapore-airbnb-disappointed). Therefore, it was surprising to discover data sets for Airbnb listings located in Singapore in [Inside Airbnb]('http://insideairbnb.com/about.html'). But we shall dive deeper into this phenomenon of Airbnb being allowed in Singapore perhaps another day. 

For this particular exercise, we will utilising those data sets to generate useful insights through:

- Analysing the distribution of Airbnb listings in Pre-COVID Singapore using 2019 dataset
- Analysing the impact of COVID-19 on these listings based on the most updated 2021 dataset

## 1.1 Research Questions

The specific questions we are trying to find out are:

- Are the locations of Airbnb Listings spatially independent?

- If they are NOT spatially independent, what location factors (Hotels, Hawker Centres, MRT Stations, Tourist Attractions) do they cluster around to?

## 1.2 The Data

For analysis purposes, the following data are used:

- Airbnb listings for June 2019 and June 2021 from [Inside Airbnb]('http://insideairbnb.com/get-the-data.html')

- Various geospatial data sets of choice extracted from SLA OneMap Service, using [OneMap.Sg API]('https://cran.r-project.org/web/packages/onemapsgapi/index.html')

- Point location data of Mass Rapid Transit (MRT) Stations in Singapore from [Land Transport Authority Datamall]('https://datamall.lta.gov.sg/content/datamall/en.html')

# 2. Setting up the environment

To begin the study, R packages will be used for efficiency and a more comprehensive analysis, such as *tidyverse* and *sf* etc.

```{r results='hide'}

packages <- c('readr','maptools', 'sf', 'raster', 'spatstat', 'tmap', 'tidyverse', 'plotly', 'ggthemes')
for (p in packages)
  {
  if(!require(p, character.only = T))
    {
    install.packages(p)
  }
  library(p,character.only = T)
}
```

# 3. Data Wrangling

## 3.1 Aspatial Data

### 3.1.1 Importing in Aspatial Data 

We will first import in data using the Airbnb (2019 and 2021) datasets, as we are interested in analysing the distribution of Airbnb listings **Pre and Post COVID-19**. For Pre-COVID context, the analysis aims to uncover whether the distribution of Airbnb listings are affected by location factors such as located near hotels or tourist attractions, so those datasets are imported in as well. 

```{r results='hide'}
airbnb_2019 <- read_csv("the2data/airbnb2019.csv")
airbnb_2021 <- read_csv("the2data/airbnb2021.csv")
sg_hotels <- read_csv("the2data/OneMapData/hotels.csv") 
tourist_attractions <- read_csv("the2data/OneMapData/tourism.csv")
```

We will also utilise an additional dataset from **SLA OneMap**, which is the **Hawker Centres** dataset. Singapore's street food or known locally as hawker food culture has helped put the tiny country on the world map, with the hawker culture being featured in international food documentary series such as [Netflix's Street Food: Asia]('https://atta.ai/media/en/singapore-hawker-stalls-featured-on-netflixs-street-food/') and also recently being recognised as a [UNESCO heritage representative of Singapore]('https://www.nationalgeographic.com/travel/article/why-unesco-is-honoring-singapore-street-food'). 

Therefore, it would be interesting to see if the location of Airbnb listings would be located near more famous Hawker Centres, such as Maxwell Road Hawker Centre and Newton Food Centre etc. 

The dataset will be imported using the One Map Api as shown in the below code chunk.

```{r eval=FALSE}
library(onemapsgapi)

hawker_centres <- get_theme('eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOjc5NTgsInVzZXJfaWQiOjc5NTgsImVtYWlsIjoianVucGVuZy50ZW8uMjAxOUBzbXUuZWR1LnNnIiwiZm9yZXZlciI6ZmFsc2UsImlzcyI6Imh0dHA6XC9cL29tMi5kZmUub25lbWFwLnNnXC9hcGlcL3YyXC91c2VyXC9zZXNzaW9uIiwiaWF0IjoxNjMxNzcyNzMzLCJleHAiOjE2MzIyMDQ3MzMsIm5iZiI6MTYzMTc3MjczMywianRpIjoiODc4OGY3NGI4Yjk5ZDZmZTI1NWFmNjExYjlkNTZiYjQifQ.N-KrWjJPHLJIQVwpBLjyDg6s0JWVNESINp7-7YjUEQI', 'hawkercentre')

write.csv(hawker_centres, "the2data/hawker_centres.csv", row.names = FALSE)
```

The hawker_centres dataset is written out as a csv for easier bookkeeping purposes

Importing in the hawker_centres from its csv file 

```{r}
hawker_centres <- read_csv(file = "the2data/hawker_centres.csv")
```

### 3.1.2 Recalibrating Projected Coordinates Systems to SVY21

The coordinates in the respective data frames were defined in values of Latitude and Longitude, therefore being congruent with **EPSG 4326**. However, Singapore's national Project Coordination Systems should be **EPSG 3414 (SVY21)** instead, therefore we will transform the *crs* to EPSG 3414.

```{r}
airbnb_2019 <- st_as_sf(airbnb_2019,
                    coords = c("longitude",
                               "latitude"),
                    crs = 4326) %>%
  st_transform(crs = 3414)

airbnb_2021 <- st_as_sf(airbnb_2021,
                    coords = c("longitude",
                               "latitude"),
                    crs = 4326) %>%
  st_transform(crs = 3414)

sg_hotels <- st_as_sf(sg_hotels,
                    coords = c("Lng",
                               "Lat"),
                    crs = 4326) %>%
  st_transform(crs = 3414)

hawker_centres <- st_as_sf(hawker_centres,
                    coords = c("Lng",
                               "Lat"),
                    crs = 4326) %>%
  st_transform(crs = 3414)
```

For tourist attractions, an extra step is needed because there are NA values, so we have to drop them. If not, we will get an error "missing values in coordinates not allowed".

```{r}
tourist_attractions <- tourist_attractions[!is.na(tourist_attractions$LATITUDE), ]
tourist_attractions <- st_as_sf(tourist_attractions,
                    coords = c("LONGTITUDE",
                               "LATITUDE"),
                    crs = 4326) %>%
  st_transform(crs = 3414)
```

Code chunk to check and ensure Projected Coordinates Systems of the sf objects is correct

```{r eval=FALSE}
st_crs(airbnb_2019)
st_crs(airbnb_2021)
st_crs(sg_hotels)
st_crs(hawker_centres)
st_crs(tourist_attractions)
```

## 3.2 Spatial Data

### 3.2.1 Importing in Geospatial Data 

Importing shapefile of **MRT Stations locations** using *st_read*()* of **sf** package. The output object will be in tibble sf object class. 

We will be looking at the correlation between location of Airbnb listings and MRT stations in Singapore. 

```{r}
mrt_sf <- st_read(dsn = "the2data/MRT", 
                layer = "MRTLRTStnPtt")
```
The output of the above code chunk showed that projection of **mrt_sf** is in SVY21, so we are good to proceed on because it is the correct projected coordinates system.

## 3.3 Geospatial Data Wrangling

### 3.3.1 Converting sf data frames into sp's Spatial* class

The code chunk below uses *as_Spatial()* of **sf** package to convert the respective geospatial data from simple feature data frames to sp’s Spatial* class.

```{r}
airbnb_2019_sp <- as_Spatial(airbnb_2019)
hotels_sp <- as_Spatial(sg_hotels)
hawker_sp <- as_Spatial(hawker_centres)
tourist_attractions_sp <- as_Spatial(tourist_attractions)
mrt_sp <- as_Spatial(mrt_sf)
```

Taking a look at a chosen few of the above data frames to ensure that they are converted to Spatial* classes successfully.

```{r}
airbnb_2019_sp
```
```{r}
hotels_sp
```
### 3.3.2 Converting the Spatial* classes into generic sp format

This conversion is required because **spatstat** only takes in analytical data in **ppp** object form. 

The below code chunks converts the Spatial* classes into generic sp objects.

```{r}
airbnb_2019_sp <- as(airbnb_2019_sp, "SpatialPoints")
hotels_sp <- as(hotels_sp, "SpatialPoints")
hawker_sp <- as(hawker_sp, "SpatialPoints")
tourist_attractions_sp <- as(tourist_attractions_sp, "SpatialPoints")
mrt_sp <- as(mrt_sp, "SpatialPoints")
```

Taking a look at a chosen few of the above Spatial* classes to ensure that they are converted to generic sp objects successfully.

```{r}
hawker_sp
```

```{r}
mrt_sp
```
### 3.3.3 Converting the generic sp objects into spatstat's ppp format

In this step, we will use *as.ppp()* function of **spatstat** to convert the spatial data into **spatstat’s ppp** object format.

```{r}
airbnb_2019_ppp <- as(airbnb_2019_sp, "ppp")
hotels_ppp <- as(hotels_sp, "ppp")
hawker_ppp <- as(hawker_sp, "ppp")
tourist_attractions_ppp <- as(tourist_attractions_sp, "ppp")
mrt_ppp <- as(mrt_sp, "ppp")
```

- Plotting **airbnb_2019_ppp** to see the change in visualisation

```{r}
plot(airbnb_2019_ppp)
```
- Taking a quick look at the summary statistics of **airbnb_2019_ppp**

```{r}
summary(airbnb_2019_ppp)
```
### 3.3.4 Handling duplicated points in ppp objects

Duplicated points are commonly found in ppp objects as shown in the output above, and the presence of duplicates will affect the accuracy of the spatial point patterns analysis, therefore we have to handle these duplicates in this section. 

We will use the **jittering** approach, which adds a small perturbation to the duplicate points so they would not occupy the exact same space and point as their originals.

```{r}
airbnb2019_ppp_jit <- rjitter(airbnb_2019_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)

hawker_ppp_jit <- rjitter(hawker_ppp,
                            retry=TRUE,
                            nsim=1,
                            drop=TRUE)

tourism_ppp_jit <- rjitter(tourist_attractions_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)

hotels_ppp_jit <- rjitter(hotels_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)

mrt_ppp_jit <- rjitter(mrt_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
```

- Checking for any duplicates in the jittered ppp objects

```{r}
any(duplicated(airbnb2019_ppp_jit))
```
### 3.3.5 Creating an *owin* object

When doing spatial point patterns analysis, a good practice to always follow is to confine the analysis with a geographical area such as Singapore's boundary. In **spatstat**, this polygonal region is known as **owin**, an object specially designed to represent this boundary.

```{r}
sg <- st_read(dsn = "the2data/sgdata", layer="CostalOutline")

sg <- st_transform(sg, crs = 3414)

sg_sp <- as(as_Spatial(sg), "SpatialPolygons")

sg <- st_make_valid(sg)
```

The code chunk below is used to convert **sg** SpatialPolygon object into **owin** object of **spatstat**.

```{r}
sg_owin <- as(sg_sp, "owin")
```

- Quick look at visualisation of Airbnb Listings 2019 and Singapore's boundary

The output object combined both the point and polygon feature in one ppp object class as shown below.

```{r}
airbnb_2019_ppp = airbnb2019_ppp_jit[sg_owin]
hawker_ppp = hawker_ppp_jit[sg_owin]
tourist_attractions_ppp = tourism_ppp_jit[sg_owin]
hotels_ppp = hotels_ppp_jit[sg_owin]
mrt_ppp = mrt_ppp_jit[sg_owin]

plot(airbnb_2019_ppp)
```

# 4. Section A: Distribution of Airbnb Listings in 2019

## 4.1 Exploratory Spatial Data Analysis

### 4.1.1 Exploratory Geospatial Analysis

Taking a quick look at the distribution of Airbnb listings

```{r}
mpsz_sf <- st_read(dsn = "the2data/sgdata", 
                layer = "MP14_SUBZONE_WEB_PL")

tmap_mode("plot")
tm_shape(mpsz_sf) +
  tm_polygons() +
  tm_shape(airbnb_2019) +
  tm_dots()
```

### 4.1.2 First-order Spatial Point Patterns Analysis (Data Processing)

First-order Spatial Point Patterns Analysis (SPPA) will be performed using **spatstat** package.

Kernel Density Maps will be used to unravel spatial patterns between the location of listings and various location factors mentioned earlier on. The advantage of using Kernel Density over Point Density is that the results are much more spatially accurate, because Point Density usually produces more steep edges which is not desirable. 

On the other hand, Kernel density gives smoother results that allows for plotting nicer visuals, which is **crucial** for getting substantial analysis insights. 

![Visual comparison of Point Density vs Kernel Density](DensityPoint.png)

#### Computing kernel density values 

The code chunk below computes a kernel density by using the following configurations of *density()* of **spatstat**, with automatic bandwidth selection method used (*bw.diggle()*). 

Thereafter, the *plot()* function of Base R is then used to display the kernel density derived. 

*P.S. We will only use Airbnb 2019 to plot this exploratory map, as we are only interested in seeing how the values looked so the Airbnb 2019 data will be used as a reference for the others*

```{r}
kde_airbnb2019_bw  <- density(airbnb_2019_ppp, sigma=bw.diggle, edge=TRUE, kernel="gaussian")

plot(kde_airbnb2019_bw, main="Airbnb Listings (original)")
```
Notice the very small values being produced, this is resulted from a mismatch of measurement, thus we will rescale the units in the next section.

#### Rescaling KDE values

Rescaling is essential because the unit of measurement does not match, resulting in very small values. Therefore, we will rescale the unit of measurement from meter to kilometer, and compute the kernel density again.  

```{r}
kde_airbnb2019.km <- rescale(airbnb_2019_ppp, 1000, "km")
kde_hawker.km <- rescale(hawker_ppp, 1000, "km")
kde_tourism.km <- rescale(tourist_attractions_ppp, 1000, "km")
kde_hotels.km <- rescale(hotels_ppp, 1000, "km")
kde_mrt.km <- rescale(mrt_ppp, 1000, "km")
```

```{r}
kde_airbnb2019.bw  <- density(kde_airbnb2019.km, sigma=1, edge=TRUE, kernel="gaussian")
kde_hawker.bw  <- density(kde_hawker.km, sigma=1, edge=TRUE, kernel="gaussian")
kde_tourism.bw  <- density(kde_tourism.km, sigma=1, edge=TRUE, kernel="gaussian")
kde_hotels.bw  <- density(kde_hotels.km, sigma=1, edge=TRUE, kernel="gaussian")
kde_mrt.bw  <- density(kde_mrt.km, sigma=1, edge=TRUE, kernel="gaussian")
```

And finally plot the map again (which should have bigger values).

```{r fig.width=8, fig.height=6}
par(mfrow=c(2,3))

plot(kde_airbnb2019.bw, main="Airbnb Listings 2019 (km)")
plot(kde_hawker.bw, main="Hawker Centres (km)")
plot(kde_tourism.bw, main="Tourist Attractions (km)")
plot(kde_hotels.bw, main="Hotels (km)")
plot(kde_mrt.bw, main="MRT Stations (km)")
```

#### Converting KDE outputs into grid objects

This conversion does not change the output results, it just makes it more suitable for mapping purposes.

```{r}
gridded_kde_airbnb2019_bw <- as.SpatialGridDataFrame.im(kde_airbnb2019.bw)
gridded_kde_hawker_bw <- as.SpatialGridDataFrame.im(kde_hawker.bw)
gridded_kde_tourism_bw <- as.SpatialGridDataFrame.im(kde_tourism.bw)
gridded_kde_hotels_bw <- as.SpatialGridDataFrame.im(kde_hotels.bw)
gridded_kde_mrt_bw <- as.SpatialGridDataFrame.im(kde_mrt.bw)
```

#### Converting Gridded outputs into Raster

Next, we will convert the gridded kernal density objects into RasterLayer object by using *raster()* of **raster** package.

```{r}
kde_airbnb_2019_bw_raster <- raster(gridded_kde_airbnb2019_bw)
kde_hawker_bw_raster <- raster(gridded_kde_hawker_bw)
kde_tourism_bw_raster <- raster(gridded_kde_tourism_bw)
kde_hotels_bw_raster <- raster(gridded_kde_hotels_bw)
kde_mrt_bw_raster <- raster(gridded_kde_mrt_bw)

kde_airbnb_2019_bw_raster
```
We need to reassign the projected systems to the new Raster layer, because the crs will be lost (as shown in above output) when converting into a ppp object earlier on. 

The below code chunk will assign the projected systems to the Raster layer.

```{r}
projection(kde_airbnb_2019_bw_raster) <- CRS("+init=EPSG:3414 +datum=WGS84 +units=km")
projection(kde_hawker_bw_raster) <- CRS("+init=EPSG:3414 +datum=WGS84 +units=km")
projection(kde_tourism_bw_raster) <- CRS("+init=EPSG:3414 +datum=WGS84 +units=km")
projection(kde_hotels_bw_raster) <- CRS("+init=EPSG:3414 +datum=WGS84 +units=km")
projection(kde_mrt_bw_raster) <- CRS("+init=EPSG:3414 +datum=WGS84 +units=km")

kde_airbnb_2019_bw_raster
```
### 4.1.3 First-order Spatial Point Patterns Analysis (Plotting of Maps)

Finally, we can then plot the processed data into cartographic quality maps using **tmap** package.

#### Kernel Density Map of Airbnb Listings 2019

```{r}
tmap_mode("view")

tm_shape(sg) +
  tm_borders(col = 'black',
             lwd = 1,
             alpha = 0.5) +
tm_shape(kde_airbnb_2019_bw_raster) + 
  tm_raster("v", alpha = 0.7) +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE, title = "Kernel Density of Airbnb Listings 2019") +
  tm_basemap('OpenStreetMap')
```

As shown in the visualisation above, the raster values are encoded explicitly onto the raster pixel using the values in "v" field. 

#### Kernel Density Map of existing Hotels

```{r eval=FALSE}
tmap_mode("plot")

tm_shape(sg) +
  tm_borders(col = 'black',
             lwd = 1,
             alpha = 0.5) +
tm_shape(kde_hotels_bw_raster) + 
  tm_raster("v", alpha = 0.7) +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE, title = "Kernel Density of existing Hotels") +
  tm_basemap('OpenStreetMap')
```
![Screenshot of Kernel Density of Hotels](KDHotels.png)

#### Kernel Density Map of MRT Stations

```{r eval=FALSE}
tm_shape(sg) +
  tm_borders(col = 'black',
             lwd = 1,
             alpha = 0.5) +
tm_shape(kde_mrt_bw_raster) + 
  tm_raster("v", alpha = 0.7) +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE, title = "Kernel Density of MRT Stations") +
  tm_basemap('OpenStreetMap')
```
![Screenshot of Kernel Density of MRT stations](KDmrt.png)

#### Kernel Density Map of Tourist Attractions

```{r eval=FALSE}
tm_shape(sg) +
  tm_borders(col = 'black',
             lwd = 1,
             alpha = 0.5) +
tm_shape(kde_tourism_bw_raster) + 
  tm_raster("v", alpha = 0.7) +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE, title = "Kernel Density of Tourist Attractions") +
  tm_basemap('OpenStreetMap')
```
![Screenshot of Kernel Density of Tourist Attractions](KDTourist.png)

#### Kernel Density Map of Hawker Centres

```{r eval=FALSE}
tm_shape(sg) +
  tm_borders(col = 'black',
             lwd = 1,
             alpha = 0.5) +
tm_shape(kde_hawker_bw_raster) + 
  tm_raster("v", alpha = 0.7) +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE, title = "Kernel Density of Hawker Centres") +
  tm_basemap('OpenStreetMap')
```
![Screenshot of Kernel Density of Hawker Centres](KDHawker.png)

From the above plotted maps, we can see a common spatial pattern among all of them:

- The Airbnb Listings seems to clusters around the central/south of Singapore, where the Central Region is located in. 
- This is not surprising as the more **famous landmarks or tourist attractions** of Singapore are located in that area, such as the Merlion, Marina Bay Sands to name a few.
- Therefore, it makes perfect sense for most Airbnb listings to be located that area. Similarly, the other location factors (Hotels and Hawker Centres) would be concentrated around that same area as well, so as to **maximize footfall and tourist spending**. 
- For MRT stations, there is concentration around that area as well, with shorter distance between stations, such as **City Hall MRT and Esplande MRT**, which are well within a 10 minutes' walk. Thus, it is easy to see why properties in the area would be strategically listed on Airbnb, because having more MRT stations means higher accessibility for visitors. 

#### Extract Central Region area for targeted analysis

The following code chunk will be used to load and extract the Central Region area.

```{r}
mpsz <- st_read(dsn = "the2data/sgdata", 
                layer = "MP14_SUBZONE_WEB_PL")

central_area = mpsz[mpsz$REGION_N == 'CENTRAL REGION', ]
```

- Plotting out the extracted Central Region area

```{r fig.width=6, fig.height=4}
plot(st_geometry(central_area), main = 'Central Region')
```
- Converting the Central Region spatial point data frame into ppp object

```{r}
central_sp = as(as_Spatial(central_area), "SpatialPolygons")

central_owin = as(central_sp, "owin")

airbnb2019_central_ppp = airbnb_2019_ppp[central_owin]
hawker_central_ppp = hawker_ppp[central_owin]
tourism_central_ppp = tourist_attractions_ppp[central_owin]
hotels_central_ppp = hotels_ppp[central_owin]
mrt_central_ppp = mrt_ppp[central_owin]

plot(airbnb2019_central_ppp, main='Central Region')
```
#### Nearest Neighbour Index for Central Region using Clark-Evans test of aggregation

In this section, we will perform the Clark-Evans test of aggregation for a spatial point pattern by using *clarkevans.test()* of **statspat**.

The test hypotheses are:

Ho = The distribution of Airbnb Listings in the Central Region are randomly distributed.

H1 = The distribution of Airbnb Listings in the Central Region are not randomly distributed.

The 95% confident interval will be used. The null hypothesis will be rejected if p-value is smaller than alpha value of 0.05.

```{r eval=FALSE}
clarkevans.test(airbnb2019_central_ppp,
                correction='none',
                clipregion = NULL,
                alternative=c("two.sided"),
                nsim=999)
```
![](clarkevans.png)

As shown by the output above, the p-value is smaller than 0.05. Therefore, we will reject the null hypothesis that the Airbnb Listings are randomly distributed, meaning the spatial patterns are statistically significant and does show signs of clustering. 

## 4.2 Second-order Spatial Point Patterns Analysis

### 4.2.1 Data preparation 

Using the code chunk below, we will combine Airbnb Listings with the respective Location Factors into one object for use in the later analyses.

The end result is a simple feature data frame named **combined_df**.

```{r}
c_airbnb2019 <- airbnb_2019 %>%
  select("name", "geometry")

c_airbnb2019$TYPE <- "Airbnb"

names(c_airbnb2019)[names(c_airbnb2019) == 'name'] <- 'NAME'

c_hawker <- hawker_centres %>%
  select("NAME", "geometry")

c_hawker$TYPE <- "Hawker"

c_hotels <- sg_hotels %>%
  select("NAME", "geometry")

c_hotels$TYPE <- "Hotels"

c_mrt <- mrt_sf %>%
  select("STN_NAME", "geometry")

names(c_mrt)[names(c_mrt) == 'STN_NAME'] <- 'NAME'

c_mrt$TYPE <- "MRT"

c_tourism <- tourist_attractions %>%
  select("NAME", "geometry")

c_tourism$TYPE <- "Tourism"

combined_df <- rbind(c_airbnb2019, c_hawker, c_hotels, c_tourism)
```

We face issues when combining the mrt dataset into combined_df, therefore we will exclude mrt from the analysis.

The following code chunk will then change **combined_df** into a Spatial Point Data Frame, then change the Type field from character data type to factor type. 

The next conversion will be converting into a PPP object which is required by **spatstat** package, and using the *jitter()* method to remove duplicates from the PPP object.

```{r}
combined_sp <- as(as_Spatial(combined_df), "SpatialPointsDataFrame")

combined_sp@data$TYPE <- as.factor(combined_sp@data$TYPE)

combined_ppp <- as(combined_sp, "ppp")

combined_ppp_jit <- rjitter(combined_ppp, retry=TRUE, nsim=1, drop=TRUE)

combined_central_ppp = combined_ppp_jit[central_owin]

marks(combined_central_ppp) <- factor(combined_central_ppp$marks$TYPE)
```

#### Analysing Marked Point Patterns

Using the code chunk below, *density()* will be used to compute the kernel density for the respective objects. Then, plot() is used to plot the output kernel density objects derived.

```{r fig.width=12, fig.height=8}
plot(density(split(rescale(combined_central_ppp, 1000))))
```
Then, we are using *intensity()* of **spatstat** package is used to reveal the density of the respective factors as shown in the code chunk below.

```{r}
intensity(rescale(combined_central_ppp, 1000))
```
The output reveals that in the Central Region study area:

- Airbnb Listings has the highest density of 48.86 units per km square
- In comparison, there are only 2.96 hotels per km square, so it is a drastic difference
- Tourist Attractions and Hawker Centres has even lesser units per km square, with 0.67 and 0.51 units respectively

### 4.2.1 Analysing Spatial Point Process: Cross K-Function

Using the **Cross K-Function** from *Kcross()* of **spatstat** package, we can determine if the location of Airbnb Listings are close or far away from the other location factors. 

This helps us analyse the relationship between Airbnb listings and the respective location factors (Hawker Centres, Hotels etc).

#### Relationship of Airbnb Listings and Hotels: Cross K graph 

```{r}
Airbnb_Hotels_Kcross <- Kcross(combined_central_ppp,
                           i="Airbnb", j="Hotels",
                           correction='border')
plot(Airbnb_Hotels_Kcross)
```
The plot above reveals that the marked spatial point events are **not spatially independent**. However, we will do a hypothesis test to confirm this observation.

#### Relationship of Airbnb Listings and Hotels: Complete Spatial Randomness (CSR) statistical testing 

The test hypotheses are as follows:

Ho = The distribution of Airbnb Listings and Hotels are spatially independent.

H1 = The distribution of Airbnb Listings and Hotels are NOT spatially independent.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001 (i.e. at 99.9% confident interval).

In order to perform the CSR test, the *envelope()* of **spatstat** package will be used.

```{r eval=FALSE}
Airbnb_Hotels_Kcross.csr <- envelope(combined_central_ppp, Kcross, i="Airbnb", j="Hotels", correction='border', nsim=999)
```

```{r echo=FALSE}
Airbnb_Hotels_Kcross.csr <- read_rds("the2data/rds/Airbnb_Hotels_Kcross.csr.rds")
```

```{r}
plot(Airbnb_Hotels_Kcross.csr, xlab="distance(m)", xlim=c(0,500))
```
The plot above reveals that the distribution of Airbnb Listings and Hotels are not spatially independent. Since the observed(black) line is outside the envelope, the null hypothesis is rejected because the empirical k-cross line is not within the envelope of the 99.9% confidence interval. 

In essence, we will reject the null hypothesis because the results are statistically significant, and we can infer that there are **signs of a clustering relationship between Airbnb Listings and Hotels**.

#### Relationship of Airbnb Listings and Tourist Attractions: Cross K graph 

```{r}
Airbnb_Tourism_Kcross <- Kcross(combined_central_ppp,
                           i="Airbnb", j="Tourism",
                           correction='border')
plot(Airbnb_Tourism_Kcross)
```

The plot above reveals that the Airbnb listings and Tourist Attractions are **not spatially independent**. However, we will do a hypothesis test to confirm this observation.

#### Relationship of Airbnb Listings and Tourist Attractions: Complete Spatial Randomness (CSR) statistical testing 

The test hypotheses are as follows:

Ho = The distribution of Airbnb Listings and Tourist Attractions are spatially independent.

H1 = The distribution of Airbnb Listings and Tourist Attractions are NOT spatially independent.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001 (i.e. at 99.9% confident interval).

```{r eval=FALSE}
Airbnb_Tourism_Kcross.csr <- envelope(combined_central_ppp, Kcross, i="Airbnb", j="Tourism", correction='border', nsim=999)
```

```{r echo=FALSE}
Airbnb_Tourism_Kcross.csr <- read_rds("the2data/rds/Airbnb_Tourism_Kcross.csr.rds")
```

```{r}
plot(Airbnb_Tourism_Kcross.csr, xlab="distance(m)", xlim=c(0,500))
```

The plot above reveals that the distribution of Airbnb Listings and Tourist Attractions are not spatially independent. Although part of the observed (black) line did fall into the envelope around 180m, the majority of the observed line is not within the envelope of the 99.9% confidence interval, therefore the null hypothesis is rejected.

In essence, we will reject the null hypothesis because the results are statistically significant, and we can infer that there are **signs of a clustering relationship between Airbnb Listings and Tourist Attractions**.

#### Relationship of Airbnb Listings and Hawker Centres: Cross K graph 

```{r}
Airbnb_Hawker_Kcross <- Kcross(combined_central_ppp,
                           i="Airbnb", j="Hawker",
                           correction='border')
plot(Airbnb_Hawker_Kcross)
```

The plot above reveals that the Airbnb listings and Hawker Centres are **not spatially independent**. However, we will do a hypothesis test to confirm this observation.

#### Relationship of Airbnb Listings and Hawker Centres: Complete Spatial Randomness (CSR) statistical testing 

The test hypotheses are as follows:

Ho = The distribution of Airbnb Listings and Hawker Centres are spatially independent.

H1 = The distribution of Airbnb Listings and Hawker Centres are NOT spatially independent.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001 (i.e. at 99.9% confident interval).

In order to perform the CSR test, the *envelope()* of **spatstat** package will be used.

```{r eval=FALSE}
Airbnb_Hawker_Kcross.csr <- envelope(combined_central_ppp, Kcross, i="Airbnb", j="Hawker", correction='border', nsim=999)
```

```{r echo=FALSE}
Airbnb_Hawker_Kcross.csr <- read_rds("the2data/rds/Airbnb_Hawker_Kcross.csr.rds")
```

```{r}
plot(Airbnb_Hawker_Kcross.csr, xlab="distance(m)", xlim=c(0,500))
```

The plot above reveals that the distribution of Airbnb Listings and Hawker Centres are not spatially independent. Since the observed(black) line is outside the envelope except for smaller distances (<100m), the null hypothesis is rejected because the empirical k-cross line is not within the envelope of the 99.9% confidence interval. 

In essence, we will reject the null hypothesis because the results are statistically significant, and we can infer that there are **signs of a clustering relationship between Airbnb Listings and Hawker Centres**.

### 4.2.1 Analysing Spatial Point Process: Cross L-Function

Similar to Cross-K-Function, we can perform the CSR test by using *envelope()* of **spatstat** package will be used. L Function is used so as to normalise the results of K Function, and ensure higher accuracy of final results.

```{r fig.width=12, fig.height=8}
Airbnb_Hotels_Lcross <- Lcross(combined_central_ppp, i="Airbnb", j="Hotels", correction='border')
Airbnb_Tourism_Lcross <- Lcross(combined_central_ppp, i="Airbnb", j="Tourism", correction='border')
Airbnb_Hawker_Lcross <- Lcross(combined_central_ppp, i="Airbnb", j="Hawker", correction='border')

par(mfrow=c(2,2))
plot(Airbnb_Hotels_Lcross , . -r ~ r, xlab = "distance(m)", xlim=c(0, 500))
plot(Airbnb_Tourism_Lcross, . -r ~ r, xlab = "distance(m)", xlim=c(0, 500))
plot(Airbnb_Hawker_Lcross, . -r ~ r, xlab = "distance(m)", xlim=c(0, 500))
```

#### Relationship of Airbnb Listings and Location Factors: Complete Spatial Randomness (CSR) statistical testing

```{r eval=FALSE}
Hotels_Lcross.csr <- envelope(combined_central_ppp, Lcross, i="Airbnb", j="Hotels", correction='border', nsim=999)
Tourism_Lcross.csr <- envelope(combined_central_ppp, Lcross, i="Airbnb", j="Tourism", correction='border', nsim=999)
Hawker_Lcross.csr <- envelope(combined_central_ppp, Lcross, i="Airbnb", j="Hawker", correction='border', nsim=999)
```

```{r echo=FALSE}
Hotels_Lcross.csr <- read_rds("the2data/rds/Airbnb_Hotels_Lcross.csr.rds")
Tourism_Lcross.csr <- read_rds("the2data/rds/Airbnb_Tourism_Lcross.csr.rds")
Hawker_Lcross.csr <- read_rds("the2data/rds/Airbnb_Hawker_Lcross.csr.rds")
```

```{r}
par(mfrow=c(2,2))
plot(Hotels_Lcross.csr, . -r ~ r, xlab="distance(m)", xlim=c(0,500))
plot(Tourism_Lcross.csr, . -r ~ r, xlab="distance(m)", xlim=c(0,500))
plot(Hawker_Lcross.csr, . -r ~ r, xlab="distance(m)", xlim=c(0,500))
```

The above results is in line with the earlier results obtained from Cross K Function, the null hypotheses for the respective factors are rejected, and we can infer that there are indeed **signs of clustering between the Airbnb Listings and the respective location factors**.

# 5. Section B: Impact of COVID-19 on Distribution of Airbnb Listings in 2021

In this section, we will analyse the impact of COVID-19 on Airbnb listings in Singapore, by comparing their listings data from both June 2019 and June 2021. This is why we also imported the 2021 dataset earlier on in **3. Data Wrangling ** section. 

## 5.1 Exploratory Spatial Data Analysis

### 5.1.1 Data preparation for Airbnb data subsets based on room type

We will do this for both 2019 and 2021 datasets. 

The 4 types of room types are:

- Entire home/apt
- Hotel room
- Private room
- Shared room

However, the 2019 dataset does not have **Hotel room** room type so we will exclude that room type from our analysis.

```{r}
EH2019 <- airbnb_2019[airbnb_2019$room_type == "Entire home/apt", ]
PR2019 <- airbnb_2019[airbnb_2019$room_type == "Private room", ]
SR2019 <- airbnb_2019[airbnb_2019$room_type == "Shared room", ]

EH2021 <- airbnb_2021[airbnb_2021$room_type == "Entire home/apt", ]
PR2021 <- airbnb_2021[airbnb_2021$room_type == "Private room", ]
SR2021 <- airbnb_2021[airbnb_2021$room_type == "Shared room", ]
```

#### Converting the subset dataframes into generic sp objects

```{r}
EH2019_sp = as(as_Spatial(EH2019), "SpatialPoints")
PR2019_sp = as(as_Spatial(PR2019), "SpatialPoints")
SR2019_sp = as(as_Spatial(SR2019), "SpatialPoints")

EH2021_sp = as(as_Spatial(EH2021), "SpatialPoints")
PR2021_sp = as(as_Spatial(PR2021), "SpatialPoints")
SR2021_sp = as(as_Spatial(SR2021), "SpatialPoints")
```

#### Converting generic sp objects into ppp objects

```{r}
EH2019_sp_ppp = as(EH2019_sp, "ppp")
PR2019_sp_ppp = as(PR2019_sp, "ppp")
SR2019_sp_ppp = as(SR2019_sp, "ppp")

EH2021_sp_ppp = as(EH2021_sp, "ppp")
PR2021_sp_ppp = as(PR2021_sp, "ppp")
SR2021_sp_ppp = as(SR2021_sp, "ppp")
```

#### Removing duplicate points from the pp objects

```{r}
EH2019_sp_ppp_jit = rjitter(EH2019_sp_ppp, retry=TRUE, nsim=1, drop=TRUE)
PR2019_sp_ppp_jit = rjitter(PR2019_sp_ppp, retry=TRUE, nsim=1, drop=TRUE)
SR2019_sp_ppp_jit = rjitter(SR2019_sp_ppp, retry=TRUE, nsim=1, drop=TRUE)

EH2021_sp_ppp_jit = rjitter(EH2021_sp_ppp, retry=TRUE, nsim=1, drop=TRUE)
PR2021_sp_ppp_jit = rjitter(PR2021_sp_ppp, retry=TRUE, nsim=1, drop=TRUE)
SR2021_sp_ppp_jit = rjitter(SR2021_sp_ppp, retry=TRUE, nsim=1, drop=TRUE)
```

#### Rescale the unit of measurement from Metre to Kilometre

```{r}
EH2019_sp_ppp_jit.km = rescale(EH2019_sp_ppp_jit[sg_owin], 1000, "km")
PR2019_sp_ppp_jit.km = rescale(PR2019_sp_ppp_jit[sg_owin], 1000, "km")
SR2019_sp_ppp_jit.km = rescale(SR2019_sp_ppp_jit[sg_owin], 1000, "km")

EH2021_sp_ppp_jit.km = rescale(EH2021_sp_ppp_jit[sg_owin], 1000, "km")
PR2021_sp_ppp_jit.km = rescale(PR2021_sp_ppp_jit[sg_owin], 1000, "km")
SR2021_sp_ppp_jit.km = rescale(SR2021_sp_ppp_jit[sg_owin], 1000, "km")
```

#### 5.1.2 Computing kernel density values  

```{r}
KDE_EH2019_bw <- density(EH2019_sp_ppp_jit.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
KDE_PR2019_bw <- density(PR2019_sp_ppp_jit.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
KDE_SR2019_bw <- density(SR2019_sp_ppp_jit.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")

KDE_EH2021_bw <- density(EH2021_sp_ppp_jit.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
KDE_PR2021_bw <- density(PR2021_sp_ppp_jit.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
KDE_SR2021_bw <- density(SR2021_sp_ppp_jit.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
```

```{r fig.width=8, fig.height=6}
par(mfrow=c(2,3))

plot(KDE_EH2019_bw, main="Entire Home/Apt 2019")
plot(KDE_PR2019_bw, main="Private Room 2019")
plot(KDE_SR2019_bw, main="Shared Room 2019")
plot(KDE_EH2021_bw, main="Entire Home/Apt 2021")
plot(KDE_PR2021_bw, main="Private Room 2021")
plot(KDE_SR2021_bw, main="Shared Room 2021")

```

From the results above, we can see that we didn't get substantial results by using **sigma = bw.diggle**. Therefore, we will use **sigma = 1.2** as that's the maximum bandwidth, and hopefully we will get more comprehensive results.

```{r}
KDE_EH2019_bw <- density(EH2019_sp_ppp_jit.km, sigma=1.2, edge=TRUE, kernel="gaussian")
KDE_PR2019_bw <- density(PR2019_sp_ppp_jit.km, sigma=1.2, edge=TRUE, kernel="gaussian")
KDE_SR2019_bw <- density(SR2019_sp_ppp_jit.km, sigma=1.2, edge=TRUE, kernel="gaussian")

KDE_EH2021_bw <- density(EH2021_sp_ppp_jit.km, sigma=1.2, edge=TRUE, kernel="gaussian")
KDE_PR2021_bw <- density(PR2021_sp_ppp_jit.km, sigma=1.2, edge=TRUE, kernel="gaussian")
KDE_SR2021_bw <- density(SR2021_sp_ppp_jit.km, sigma=1.2, edge=TRUE, kernel="gaussian")
```

```{r fig.width=8, fig.height=6}
par(mfrow=c(2,3))

plot(KDE_EH2019_bw, main="Entire Home/Apt 2019")
plot(KDE_PR2019_bw, main="Private Room 2019")
plot(KDE_SR2019_bw, main="Shared Room 2019")
plot(KDE_EH2021_bw, main="Entire Home/Apt 2021")
plot(KDE_PR2021_bw, main="Private Room 2021")
plot(KDE_SR2021_bw, main="Shared Room 2021")
```

Voila! Now we have better results, and we shall proceed on. 

#### Converting KDE outputs into grid objects

This conversion does not change the output results, it just makes it more suitable for mapping purposes.

```{r}
gridded_KDE_EH2019_bw <- as.SpatialGridDataFrame.im(KDE_EH2019_bw)
gridded_KDE_PR2019_bw <- as.SpatialGridDataFrame.im(KDE_PR2019_bw)
gridded_KDE_SR2019_bw <- as.SpatialGridDataFrame.im(KDE_SR2019_bw)

gridded_KDE_EH2021_bw <- as.SpatialGridDataFrame.im(KDE_EH2021_bw)
gridded_KDE_PR2021_bw <- as.SpatialGridDataFrame.im(KDE_PR2021_bw)
gridded_KDE_SR2021_bw <- as.SpatialGridDataFrame.im(KDE_SR2021_bw)
```

#### Converting Gridded outputs into Raster

Next, we will convert the gridded kernal density objects into RasterLayer object by using *raster()* of **raster** package.

```{r}
gridded_KDE_EH2019_raster <- raster(gridded_KDE_EH2019_bw)
gridded_KDE_PR2019_raster <- raster(gridded_KDE_PR2019_bw)
gridded_KDE_SR2019_raster <- raster(gridded_KDE_SR2019_bw)

gridded_KDE_EH2021_raster <- raster(gridded_KDE_EH2021_bw)
gridded_KDE_PR2021_raster <- raster(gridded_KDE_PR2021_bw)
gridded_KDE_SR2021_raster <- raster(gridded_KDE_SR2021_bw)
```

We then need to reassign the projected systems to the new Raster layer, because the crs will be lost (as shown in **3. Data Wrangling**) when converting into a ppp object earlier on. 

The below code chunk will assign the projected systems to the Raster layer.

```{r}
projection(gridded_KDE_EH2019_raster) <- CRS("+init=EPSG:3414 +datum=WGS84 +units=km")
projection(gridded_KDE_PR2019_raster) <- CRS("+init=EPSG:3414 +datum=WGS84 +units=km")
projection(gridded_KDE_SR2019_raster) <- CRS("+init=EPSG:3414 +datum=WGS84 +units=km")

projection(gridded_KDE_EH2021_raster) <- CRS("+init=EPSG:3414 +datum=WGS84 +units=km")
projection(gridded_KDE_PR2021_raster) <- CRS("+init=EPSG:3414 +datum=WGS84 +units=km")
projection(gridded_KDE_SR2021_raster) <- CRS("+init=EPSG:3414 +datum=WGS84 +units=km")
```

Finally, we can then plot the processed data into cartographic quality maps using **tmap** package.

### 5.1.3 Computing kernel density maps 

#### Kernel Density of room type (Entire Home/Apt)

```{r}
tmap_mode("view")

EH2019_map <- tm_shape(sg) +
  tm_borders(col = 'black',
             lwd = 1,
             alpha = 0.5) +
tm_shape(gridded_KDE_EH2019_raster) + 
  tm_raster("v", breaks=c(0, 20, 40, 60, 80, 100), alpha = 0.7) +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE, title = "Entire Home/Apt 2019") +
  tm_basemap('OpenStreetMap')

EH2021_map <- tm_shape(sg) +
  tm_borders(col = 'black',
             lwd = 1,
             alpha = 0.5) +
tm_shape(gridded_KDE_EH2021_raster) + 
  tm_raster("v", breaks=c(0, 20, 40, 60, 80, 100), alpha = 0.7) +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE, title = "Entire Home/Apt 2021") +
  tm_basemap('OpenStreetMap')

tmap_arrange(EH2019_map, EH2021_map, asp=1, ncol=2)
```
#### Kernel Density of room type (Private Room)

```{r}
tmap_mode("view")

PR2019_map <- tm_shape(sg) +
  tm_borders(col = 'black',
             lwd = 1,
             alpha = 0.5) +
tm_shape(gridded_KDE_PR2019_raster) + 
  tm_raster("v", breaks=c(0, 20, 40, 60, 80), alpha = 0.7) +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE, title = "Private Room 2019") +
  tm_basemap('OpenStreetMap')

PR2021_map <- tm_shape(sg) +
  tm_borders(col = 'black',
             lwd = 1,
             alpha = 0.5) +
tm_shape(gridded_KDE_PR2021_raster) + 
  tm_raster("v",breaks=c(0, 20, 40, 60, 80), alpha = 0.7) +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE, title = "Private Room 2021") +
  tm_basemap('OpenStreetMap')

tmap_arrange(PR2019_map, PR2021_map, asp=1, ncol=2)
```

#### Kernel Density of room type (Shared Room)

```{r}
tmap_mode("view")

SR2019_map <- tm_shape(sg) +
  tm_borders(col = 'black',
             lwd = 1,
             alpha = 0.5) +
tm_shape(gridded_KDE_SR2019_raster) + 
  tm_raster("v", breaks=c(0, 5, 10, 15, 20, 25), alpha = 0.7) +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE, title = "Shared Room 2019") +
  tm_basemap('OpenStreetMap')

SR2021_map <- tm_shape(sg) +
  tm_borders(col = 'black',
             lwd = 1,
             alpha = 0.5) +
tm_shape(gridded_KDE_SR2021_raster) + 
  tm_raster("v", breaks=c(0, 5, 10, 15, 20, 25), alpha = 0.7) +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE, title = "Shared Room 2021") +
  tm_basemap('OpenStreetMap')

tmap_arrange(SR2019_map, SR2021_map, asp=1, ncol=2)
```

From the plotted maps above, we can see that for all 3 Room Types, it is evident that there has been a drop in the number of units per km square from 2019 to 2021. This could be seen explicitly through the lighter greens in the 2021 maps as compared to their 2019 counterparts. 

## 5.2 Second-order Spatial Point Patterns Analysis

# 6. Conclusion

# 7. References

- [Short-term home sharing remains illegal in Singapore; Airbnb disappointed](https://www.todayonline.com/singapore/short-term-home-sharing-remains-illegal-singapore-airbnb-disappointed)

- [Kernel vs Point Density](https://community.esri.com/t5/arcgis-spatial-analyst-questions/kernel-vs-point-density/td-p/610486)


---
title: "COVID-19's Impact on the Distribution of Airbnb Listings in Singapore"
description: |
  A study on the distribution of Airbnb Listings in Singapore, and how has COVID-19 impacted them.
author:
  - name: Teo Jun Peng
    url: https://teojp3-is415.netlify.app/
date: 09-30-2021
output:
  distill::distill_article:
      self_contained: false
      toc: true
      toc_depth: 2
      toc_float: true
---

```{r setup, include=FALSE, eval=TRUE, echo=TRUE, message=FALSE, error=FALSE, fig.retina=3}
knitr::opts_chunk$set(echo = TRUE, fig.align = "center", tidy.opts=list(width.cutoff=80),tidy=TRUE)
```

# 1. Introduction

Singapore is one of the few countries that does not legalise short-term rentals for properties, a minimum stay of three months is still required for rental of properties as of [2019](https://www.todayonline.com/singapore/short-term-home-sharing-remains-illegal-singapore-airbnb-disappointed). Therefore, it was surprising to discover data sets for Airbnb listings located in Singapore in [Inside Airbnb]('http://insideairbnb.com/about.html'). But we shall dive deeper into this phenomenon of Airbnb being allowed in Singapore perhaps another day. 

For this particular exercise, we will utilising those data sets to generate useful insights through:

- Analysing the distribution of Airbnb listings in Pre-COVID Singapore using 2019 dataset
- Analysing the impact of COVID-19 on these listings based on the most updated 2021 dataset

## 1.1 Research Questions

The specific questions we are trying to find out are:

- Are the locations of Airbnb Listings spatially independent?

- If they are NOT spatially independent, what location factors (Hotels, Hawker Centres, MRT Stations, Tourist Attractions) do they cluster around to?

- Has COVID-19 affected the distribution of Airbnb Listings in Singapore? 

## 1.2 The Data

For analysis purposes, the following data are used:

- Airbnb listings for June 2019 and June 2021 from [Inside Airbnb]('http://insideairbnb.com/get-the-data.html')

- Various geospatial data sets of choice extracted from SLA OneMap Service, using [OneMap.Sg API]('https://cran.r-project.org/web/packages/onemapsgapi/index.html')

- Point location data of Mass Rapid Transit (MRT) Stations in Singapore from [Land Transport Authority Datamall]('https://datamall.lta.gov.sg/content/datamall/en.html')

# 2. Setting up the environment

To begin the study, R packages will be used for efficiency and a more comprehensive analysis, such as *tidyverse* and *sf* etc.

```{r results='hide'}

packages <- c('readr','maptools', 'sf', 'raster', 'spatstat', 'tmap', 'tidyverse', 'plotly', 'ggthemes')
for (p in packages)
  {
  if(!require(p, character.only = T))
    {
    install.packages(p)
  }
  library(p,character.only = T)
}
```

# 3. Data Wrangling

## 3.1 Aspatial Data

### 3.1.1 Importing in Aspatial Data 

We will first import in data using the Airbnb (2019 and 2021) datasets, as we are interested in analysing the distribution of Airbnb listings **Pre and Post COVID-19**. For Pre-COVID context, the analysis aims to uncover whether the distribution of Airbnb listings are affected by location factors such as located near hotels or tourist attractions, so those datasets are imported in as well. 

```{r results='hide'}
airbnb_2019 <- read_csv("the2data/airbnb2019.csv")
airbnb_2021 <- read_csv("the2data/airbnb2021.csv")
sg_hotels <- read_csv("the2data/OneMapData/hotels.csv") 
tourist_attractions <- read_csv("the2data/OneMapData/tourism.csv")
```

We will also utilise an additional dataset from **SLA OneMap**, which is the **Hawker Centres** dataset. Singapore's street food or known locally as hawker food culture has helped put the tiny country on the world map, with the hawker culture being featured in international food documentary series such as [Netflix's Street Food: Asia]('https://atta.ai/media/en/singapore-hawker-stalls-featured-on-netflixs-street-food/') and also recently being recognised as a [UNESCO heritage representative of Singapore]('https://www.nationalgeographic.com/travel/article/why-unesco-is-honoring-singapore-street-food'). 

Therefore, it would be interesting to see if the location of Airbnb listings would be located near more famous Hawker Centres, such as Maxwell Road Hawker Centre and Newton Food Centre etc. 

The dataset will be imported using the One Map Api as shown in the below code chunk.

```{r eval=FALSE}
library(onemapsgapi)

hawker_centres <- get_theme('eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOjc5NTgsInVzZXJfaWQiOjc5NTgsImVtYWlsIjoianVucGVuZy50ZW8uMjAxOUBzbXUuZWR1LnNnIiwiZm9yZXZlciI6ZmFsc2UsImlzcyI6Imh0dHA6XC9cL29tMi5kZmUub25lbWFwLnNnXC9hcGlcL3YyXC91c2VyXC9zZXNzaW9uIiwiaWF0IjoxNjMxNzcyNzMzLCJleHAiOjE2MzIyMDQ3MzMsIm5iZiI6MTYzMTc3MjczMywianRpIjoiODc4OGY3NGI4Yjk5ZDZmZTI1NWFmNjExYjlkNTZiYjQifQ.N-KrWjJPHLJIQVwpBLjyDg6s0JWVNESINp7-7YjUEQI', 'hawkercentre')

write.csv(hawker_centres, "the2data/hawker_centres.csv", row.names = FALSE)
```

The hawker_centres dataset is written out as a csv for easier bookkeeping purposes

Importing in the hawker_centres from its csv file 

```{r}
hawker_centres <- read_csv(file = "the2data/hawker_centres.csv")
```

### 3.1.2 Recalibrating Projected Coordinates Systems to SVY21

The coordinates in the respective data frames were defined in values of Latitude and Longitude, therefore being congruent with **EPSG 4326**. However, Singapore's national Project Coordination Systems should be **EPSG 3414 (SVY21)** instead, therefore we will transform the *crs* to EPSG 3414.

```{r}
airbnb_2019 <- st_as_sf(airbnb_2019,
                    coords = c("longitude",
                               "latitude"),
                    crs = 4326) %>%
  st_transform(crs = 3414)

airbnb_2021 <- st_as_sf(airbnb_2021,
                    coords = c("longitude",
                               "latitude"),
                    crs = 4326) %>%
  st_transform(crs = 3414)

sg_hotels <- st_as_sf(sg_hotels,
                    coords = c("Lng",
                               "Lat"),
                    crs = 4326) %>%
  st_transform(crs = 3414)

hawker_centres <- st_as_sf(hawker_centres,
                    coords = c("Lng",
                               "Lat"),
                    crs = 4326) %>%
  st_transform(crs = 3414)
```

For tourist attractions, an extra step is needed because there are NA values, so we have to drop them. If not, we will get an error "missing values in coordinates not allowed".

```{r}
tourist_attractions <- tourist_attractions[!is.na(tourist_attractions$LATITUDE), ]
tourist_attractions <- st_as_sf(tourist_attractions,
                    coords = c("LONGTITUDE",
                               "LATITUDE"),
                    crs = 4326) %>%
  st_transform(crs = 3414)
```

Code chunk to check and ensure Projected Coordinates Systems of the sf objects is correct

```{r eval=FALSE}
st_crs(airbnb_2019)
st_crs(airbnb_2021)
st_crs(sg_hotels)
st_crs(hawker_centres)
st_crs(tourist_attractions)
```

## 3.2 Spatial Data

### 3.2.1 Importing in Geospatial Data 

Importing shapefile of **MRT Stations locations** using *st_read*()* of **sf** package. The output object will be in tibble sf object class. 

We will be looking at the correlation between location of Airbnb listings and MRT stations in Singapore. 

```{r}
mrt_sf <- st_read(dsn = "the2data/MRT", 
                layer = "MRTLRTStnPtt")
```
The output of the above code chunk showed that projection of **mrt_sf** is in SVY21, so we are good to proceed on because it is the correct projected coordinates system.

## 3.3 Geospatial Data Wrangling

### 3.3.1 Converting sf data frames into sp's Spatial* class

The code chunk below uses *as_Spatial()* of **sf** package to convert the respective geospatial data from simple feature data frames to sp’s Spatial* class.

```{r}
airbnb_2019_sp <- as_Spatial(airbnb_2019)
hotels_sp <- as_Spatial(sg_hotels)
hawker_sp <- as_Spatial(hawker_centres)
tourist_attractions_sp <- as_Spatial(tourist_attractions)
mrt_sp <- as_Spatial(mrt_sf)
```

Taking a look at a chosen few of the above data frames to ensure that they are converted to Spatial* classes successfully.

```{r}
airbnb_2019_sp
```
```{r}
hotels_sp
```
### 3.3.2 Converting the Spatial* classes into generic sp format

This conversion is required because **spatstat** only takes in analytical data in **ppp** object form. 

The below code chunks converts the Spatial* classes into generic sp objects.

```{r}
airbnb_2019_sp <- as(airbnb_2019_sp, "SpatialPoints")
hotels_sp <- as(hotels_sp, "SpatialPoints")
hawker_sp <- as(hawker_sp, "SpatialPoints")
tourist_attractions_sp <- as(tourist_attractions_sp, "SpatialPoints")
mrt_sp <- as(mrt_sp, "SpatialPoints")
```

Taking a look at a chosen few of the above Spatial* classes to ensure that they are converted to generic sp objects successfully.

```{r}
hawker_sp
```

```{r}
mrt_sp
```
### 3.3.3 Converting the generic sp objects into spatstat's ppp format

In this step, we will use *as.ppp()* function of **spatstat** to convert the spatial data into **spatstat’s ppp** object format.

```{r}
airbnb_2019_ppp <- as(airbnb_2019_sp, "ppp")
hotels_ppp <- as(hotels_sp, "ppp")
hawker_ppp <- as(hawker_sp, "ppp")
tourist_attractions_ppp <- as(tourist_attractions_sp, "ppp")
mrt_ppp <- as(mrt_sp, "ppp")
```

- Plotting **airbnb_2019_ppp** to see the change in visualisation

```{r}
plot(airbnb_2019_ppp)
```
- Taking a quick look at the summary statistics of **airbnb_2019_ppp**

```{r}
summary(airbnb_2019_ppp)
```
### 3.3.4 Handling duplicated points in ppp objects

Duplicated points are commonly found in ppp objects as shown in the output above, and the presence of duplicates will affect the accuracy of the spatial point patterns analysis, therefore we have to handle these duplicates in this section. 

We will use the **jittering** approach, which adds a small perturbation to the duplicate points so they would not occupy the exact same space and point as their originals.

```{r}
airbnb2019_ppp_jit <- rjitter(airbnb_2019_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)

hawker_ppp_jit <- rjitter(hawker_ppp,
                            retry=TRUE,
                            nsim=1,
                            drop=TRUE)

tourism_ppp_jit <- rjitter(tourist_attractions_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)

hotels_ppp_jit <- rjitter(hotels_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)

mrt_ppp_jit <- rjitter(mrt_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
```

- Checking for any duplicates in the jittered ppp objects

```{r}
any(duplicated(airbnb2019_ppp_jit))
```
### 3.3.5 Creating an *owin* object

When doing spatial point patterns analysis, a good practice to always follow is to confine the analysis with a geographical area such as Singapore's boundary. In **spatstat**, this polygonal region is known as **owin**, an object specially designed to represent this boundary.

```{r}
sg <- st_read(dsn = "the2data/sgdata", layer="CostalOutline")

sg <- st_transform(sg, crs = 3414)

sg_sp <- as(as_Spatial(sg), "SpatialPolygons")

sg <- st_make_valid(sg)
```

The code chunk below is used to convert **sg** SpatialPolygon object into **owin** object of **spatstat**.

```{r}
sg_owin <- as(sg_sp, "owin")
```

- Quick look at visualisation of Airbnb Listings 2019 and Singapore's boundary

The output object combined both the point and polygon feature in one ppp object class as shown below.

```{r}
airbnb_2019_ppp = airbnb2019_ppp_jit[sg_owin]
hawker_ppp = hawker_ppp_jit[sg_owin]
tourist_attractions_ppp = tourism_ppp_jit[sg_owin]
hotels_ppp = hotels_ppp_jit[sg_owin]
mrt_ppp = mrt_ppp_jit[sg_owin]

plot(airbnb_2019_ppp)
```

# 4. Section A: Distribution of Airbnb Listings in 2019

## 4.1 Exploratory Spatial Data Analysis

### 4.1.1 Exploratory Geospatial Analysis

Taking a quick look at the distribution of Airbnb listings

```{r}
mpsz_sf <- st_read(dsn = "the2data/sgdata", 
                layer = "MP14_SUBZONE_WEB_PL")

tmap_mode("plot")
tm_shape(mpsz_sf) +
  tm_polygons() +
  tm_shape(airbnb_2019) +
  tm_dots()
```

### 4.1.2 First-order Spatial Point Patterns Analysis (Data Processing)

First-order Spatial Point Patterns Analysis (SPPA) will be performed using **spatstat** package.

Kernel Density Maps will be used to unravel spatial patterns between the location of listings and various location factors mentioned earlier on. The advantage of using Kernel Density over Point Density is that the results are much more spatially accurate, because Point Density usually produces more steep edges which is not desirable. 

On the other hand, Kernel density gives smoother results that allows for plotting nicer visuals, which is **crucial** for getting substantial analysis insights. 

![Visual comparison of Point Density vs Kernel Density](DensityPoint.png)

#### Computing kernel density values 

The code chunk below computes a kernel density by using the following configurations of *density()* of **spatstat**, with automatic bandwidth selection method used (*bw.diggle()*). 

Thereafter, the *plot()* function of Base R is then used to display the kernel density derived. 

*P.S. We will only use Airbnb 2019 to plot this exploratory map, as we are only interested in seeing how the values looked so the Airbnb 2019 data will be used as a reference for the others*

```{r}
kde_airbnb2019_bw  <- density(airbnb_2019_ppp, sigma=bw.diggle, edge=TRUE, kernel="gaussian")

plot(kde_airbnb2019_bw, main="Airbnb Listings (original)")
```
Notice the very small values being produced, this is resulted from a mismatch of measurement, thus we will rescale the units in the next section.

#### Rescaling KDE values

Rescaling is essential because the unit of measurement does not match, resulting in very small values. Therefore, we will rescale the unit of measurement from meter to kilometer, and compute the kernel density again.  

```{r}
kde_airbnb2019.km <- rescale(airbnb_2019_ppp, 1000, "km")
kde_hawker.km <- rescale(hawker_ppp, 1000, "km")
kde_tourism.km <- rescale(tourist_attractions_ppp, 1000, "km")
kde_hotels.km <- rescale(hotels_ppp, 1000, "km")
kde_mrt.km <- rescale(mrt_ppp, 1000, "km")
```

```{r}
kde_airbnb2019.bw  <- density(kde_airbnb2019.km, sigma=1, edge=TRUE, kernel="gaussian")
kde_hawker.bw  <- density(kde_hawker.km, sigma=1, edge=TRUE, kernel="gaussian")
kde_tourism.bw  <- density(kde_tourism.km, sigma=1, edge=TRUE, kernel="gaussian")
kde_hotels.bw  <- density(kde_hotels.km, sigma=1, edge=TRUE, kernel="gaussian")
kde_mrt.bw  <- density(kde_mrt.km, sigma=1, edge=TRUE, kernel="gaussian")
```

And finally plot the map again (which should have bigger values).

```{r fig.width=8, fig.height=6}
par(mfrow=c(2,3))

plot(kde_airbnb2019.bw, main="Airbnb Listings 2019 (km)")
plot(kde_hawker.bw, main="Hawker Centres (km)")
plot(kde_tourism.bw, main="Tourist Attractions (km)")
plot(kde_hotels.bw, main="Hotels (km)")
plot(kde_mrt.bw, main="MRT Stations (km)")
```

#### Converting KDE outputs into grid objects

This conversion does not change the output results, it just makes it more suitable for mapping purposes.

```{r}
gridded_kde_airbnb2019_bw <- as.SpatialGridDataFrame.im(kde_airbnb2019.bw)
gridded_kde_hawker_bw <- as.SpatialGridDataFrame.im(kde_hawker.bw)
gridded_kde_tourism_bw <- as.SpatialGridDataFrame.im(kde_tourism.bw)
gridded_kde_hotels_bw <- as.SpatialGridDataFrame.im(kde_hotels.bw)
gridded_kde_mrt_bw <- as.SpatialGridDataFrame.im(kde_mrt.bw)
```

#### Converting Gridded outputs into Raster

Next, we will convert the gridded kernal density objects into RasterLayer object by using *raster()* of **raster** package.

```{r}
kde_airbnb_2019_bw_raster <- raster(gridded_kde_airbnb2019_bw)
kde_hawker_bw_raster <- raster(gridded_kde_hawker_bw)
kde_tourism_bw_raster <- raster(gridded_kde_tourism_bw)
kde_hotels_bw_raster <- raster(gridded_kde_hotels_bw)
kde_mrt_bw_raster <- raster(gridded_kde_mrt_bw)

kde_airbnb_2019_bw_raster
```
We need to reassign the projected systems to the new Raster layer, because the crs will be lost (as shown in above output) when converting into a ppp object earlier on. 

The below code chunk will assign the projected systems to the Raster layer.

```{r}
projection(kde_airbnb_2019_bw_raster) <- CRS("+init=EPSG:3414 +datum=WGS84 +units=km")
projection(kde_hawker_bw_raster) <- CRS("+init=EPSG:3414 +datum=WGS84 +units=km")
projection(kde_tourism_bw_raster) <- CRS("+init=EPSG:3414 +datum=WGS84 +units=km")
projection(kde_hotels_bw_raster) <- CRS("+init=EPSG:3414 +datum=WGS84 +units=km")
projection(kde_mrt_bw_raster) <- CRS("+init=EPSG:3414 +datum=WGS84 +units=km")

kde_airbnb_2019_bw_raster
```
### 4.1.3 First-order Spatial Point Patterns Analysis (Plotting of Maps)

Finally, we can then plot the processed data into cartographic quality maps using **tmap** package.

*P.S. To avoid facing issues with deploying the study to Netlify, only one leaflet/interactive map will be utilised (the first map). The other maps will be shown as screenshots instead, however this should not affect the analysis as they are visually effective as well. *

#### Kernel Density Map of Airbnb Listings 2019

```{r}
tmap_mode("view")

tm_shape(sg) +
  tm_borders(col = 'black',
             lwd = 1,
             alpha = 0.5) +
tm_shape(kde_airbnb_2019_bw_raster) + 
  tm_raster("v", alpha = 0.7) +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE, title = "Kernel Density of Airbnb Listings 2019") +
  tm_basemap('OpenStreetMap')
```

As shown in the visualisation above, the raster values are encoded explicitly onto the raster pixel using the values in "v" field. 

#### Kernel Density Map of existing Hotels

```{r eval=FALSE}
tmap_mode("plot")

tm_shape(sg) +
  tm_borders(col = 'black',
             lwd = 1,
             alpha = 0.5) +
tm_shape(kde_hotels_bw_raster) + 
  tm_raster("v", alpha = 0.7) +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE, title = "Kernel Density of existing Hotels") +
  tm_basemap('OpenStreetMap')
```
![Screenshot of Kernel Density of Hotels](KDHotels.png)

#### Kernel Density Map of MRT Stations

```{r eval=FALSE}
tm_shape(sg) +
  tm_borders(col = 'black',
             lwd = 1,
             alpha = 0.5) +
tm_shape(kde_mrt_bw_raster) + 
  tm_raster("v", alpha = 0.7) +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE, title = "Kernel Density of MRT Stations") +
  tm_basemap('OpenStreetMap')
```
![Screenshot of Kernel Density of MRT stations](KDmrt.png)

#### Kernel Density Map of Tourist Attractions

```{r eval=FALSE}
tm_shape(sg) +
  tm_borders(col = 'black',
             lwd = 1,
             alpha = 0.5) +
tm_shape(kde_tourism_bw_raster) + 
  tm_raster("v", alpha = 0.7) +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE, title = "Kernel Density of Tourist Attractions") +
  tm_basemap('OpenStreetMap')
```
![Screenshot of Kernel Density of Tourist Attractions](KDTourist.png)

#### Kernel Density Map of Hawker Centres

```{r eval=FALSE}
tm_shape(sg) +
  tm_borders(col = 'black',
             lwd = 1,
             alpha = 0.5) +
tm_shape(kde_hawker_bw_raster) + 
  tm_raster("v", alpha = 0.7) +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE, title = "Kernel Density of Hawker Centres") +
  tm_basemap('OpenStreetMap')
```
![Screenshot of Kernel Density of Hawker Centres](KDHawker.png)

From the above plotted maps, we can see a common spatial pattern among all of them:

- The Airbnb Listings seems to clusters around the central/south of Singapore, where the Central Region is located in. 
- This is not surprising as the more **famous landmarks or tourist attractions** of Singapore are located in that area, such as the Merlion, Marina Bay Sands to name a few.
- Therefore, it makes perfect sense for most Airbnb listings to be located that area. Similarly, the other location factors (Hotels and Hawker Centres) would be concentrated around that same area as well, so as to **maximize footfall and tourist spending**. 
- For MRT stations, there is concentration around that area as well, with shorter distance between stations, such as **City Hall MRT and Esplande MRT**, which are well within a 10 minutes' walk. Thus, it is easy to see why properties in the area would be strategically listed on Airbnb, because having more MRT stations means higher accessibility for visitors. 

#### Extract Central Region area for targeted analysis

Since majority of the Airbnb Listings are located in the Central Region, we will be scoping down the analysis to the Central Region as our study area.

The following code chunk will be used to load and extract the Central Region area.

```{r}
mpsz <- st_read(dsn = "the2data/sgdata", 
                layer = "MP14_SUBZONE_WEB_PL")

central_area = mpsz[mpsz$REGION_N == 'CENTRAL REGION', ]
```

- Plotting out the extracted Central Region area

```{r fig.width=6, fig.height=4}
plot(st_geometry(central_area), main = 'Central Region')
```
- Converting the Central Region spatial point data frame into ppp object

```{r}
central_sp = as(as_Spatial(central_area), "SpatialPolygons")

central_owin = as(central_sp, "owin")

airbnb2019_central_ppp = airbnb_2019_ppp[central_owin]
hawker_central_ppp = hawker_ppp[central_owin]
tourism_central_ppp = tourist_attractions_ppp[central_owin]
hotels_central_ppp = hotels_ppp[central_owin]
mrt_central_ppp = mrt_ppp[central_owin]

plot(airbnb2019_central_ppp, main='Central Region')
```
#### Nearest Neighbour Index for Central Region using Clark-Evans test of aggregation

In this section, we will perform the Clark-Evans test of aggregation for a spatial point pattern by using *clarkevans.test()* of **statspat**.

The test hypotheses are:

Ho = The distribution of Airbnb Listings in the Central Region are randomly distributed.

H1 = The distribution of Airbnb Listings in the Central Region are not randomly distributed.

The 95% confident interval will be used. The null hypothesis will be rejected if p-value is smaller than alpha value of 0.05.

```{r eval=FALSE}
clarkevans.test(airbnb2019_central_ppp,
                correction='none',
                clipregion = NULL,
                alternative=c("two.sided"),
                nsim=999)
```
![](clarkevans.png)

As shown by the output above, the p-value is smaller than 0.05. Therefore, we will reject the null hypothesis that the Airbnb Listings are randomly distributed, meaning the spatial patterns are statistically significant and does show signs of clustering. 

## 4.2 Second-order Spatial Point Patterns Analysis

### 4.2.1 Data Preparation 

Using the code chunk below, we will combine Airbnb Listings with the respective Location Factors into one object for use in the later analyses.

The end result is a simple feature data frame named **combined_df**.

```{r}
c_airbnb2019 <- airbnb_2019 %>%
  select("name", "geometry")

c_airbnb2019$TYPE <- "Airbnb"

names(c_airbnb2019)[names(c_airbnb2019) == 'name'] <- 'NAME'

c_hawker <- hawker_centres %>%
  select("NAME", "geometry")

c_hawker$TYPE <- "Hawker"

c_hotels <- sg_hotels %>%
  select("NAME", "geometry")

c_hotels$TYPE <- "Hotels"

c_mrt <- mrt_sf %>%
  select("STN_NAME", "geometry")

names(c_mrt)[names(c_mrt) == 'STN_NAME'] <- 'NAME'

c_mrt$TYPE <- "MRT"

c_tourism <- tourist_attractions %>%
  select("NAME", "geometry")

c_tourism$TYPE <- "Tourism"

combined_df <- rbind(c_airbnb2019, c_hawker, c_hotels, c_tourism)
```

We face issues when combining the mrt dataset into combined_df, therefore we will **exclude mrt** from the analysis.

The following code chunk will then change **combined_df** into a Spatial Point Data Frame, then change the Type field from character data type to factor type. 

The next conversion will be converting into a PPP object which is required by **spatstat** package, and using the *jitter()* method to remove duplicates from the PPP object.

```{r}
combined_sp <- as(as_Spatial(combined_df), "SpatialPointsDataFrame")

combined_sp@data$TYPE <- as.factor(combined_sp@data$TYPE)

combined_ppp <- as(combined_sp, "ppp")

combined_ppp_jit <- rjitter(combined_ppp, retry=TRUE, nsim=1, drop=TRUE)

combined_central_ppp = combined_ppp_jit[central_owin]

marks(combined_central_ppp) <- factor(combined_central_ppp$marks$TYPE)
```

As shown in the above code chunk, the *marks()* function is used to assign the marks to SR_combined_central_ppp and affix a multitype attribute to it. This process is essential, because **multitype attribute** is needed for **Marked Point Patterns** and **K-Cross/L-Cross function** to run. 

#### Analysing Marked Point Patterns

Using the code chunk below, *density()* will be used to compute the kernel density for the respective objects. Then, plot() is used to plot the output kernel density objects derived.

```{r fig.width=12, fig.height=8}
plot(density(split(rescale(combined_central_ppp, 1000))))
```
Then, we are using *intensity()* of **spatstat** package is used to reveal the density of the respective factors as shown in the code chunk below.

```{r}
intensity(rescale(combined_central_ppp, 1000))
```
The output reveals that in the Central Region study area:

- **Airbnb Listings** has the highest density of **48.86 units per km square**
- In comparison, there are only **2.96 hotels per km square**, so it is a drastic difference
- **Tourist Attractions** and **Hawker Centres** has even lesser units per km square, with **0.67** and **0.51** units respectively

### 4.2.2 Analysing Spatial Point Process: Cross K-Function

Using the **Cross K-Function** from *Kcross()* of **spatstat** package, we can determine if the location of Airbnb Listings are close or far away from the other location factors. 

This helps us analyse the relationship between Airbnb listings and the respective location factors (Hawker Centres, Hotels etc).

#### Relationship of Airbnb Listings and Hotels: Cross K graph 

```{r}
Airbnb_Hotels_Kcross <- Kcross(combined_central_ppp,
                           i="Airbnb", j="Hotels",
                           correction='border')
plot(Airbnb_Hotels_Kcross, xlim=c(0,1000))
```
The plot above reveals that the marked spatial point events are **not spatially independent**. However, we will do a hypothesis test to confirm this observation.

#### Relationship of Airbnb Listings and Hotels: Complete Spatial Randomness (CSR) statistical testing 

The test hypotheses are as follows:

Ho = The distribution of Airbnb Listings and Hotels are spatially independent.

H1 = The distribution of Airbnb Listings and Hotels are NOT spatially independent.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001 (i.e. at 99.9% confident interval).

In order to perform the CSR test, the *envelope()* of **spatstat** package will be used.

```{r eval=FALSE}
Airbnb_Hotels_Kcross.csr <- envelope(combined_central_ppp, Kcross, i="Airbnb", j="Hotels", correction='border', nsim=999)
```

```{r echo=FALSE}
Airbnb_Hotels_Kcross.csr <- read_rds("the2data/rds/Airbnb_Hotels_Kcross.csr.rds")
```

```{r}
plot(Airbnb_Hotels_Kcross.csr, xlab="distance(m)", xlim=c(0,500))
```
The plot above reveals that the distribution of Airbnb Listings and Hotels are not spatially independent. Since the observed(black) line is outside the envelope, the null hypothesis is rejected because the empirical k-cross line is not within the envelope of the 99.9% confidence interval. 

In essence, we will reject the null hypothesis because the results are statistically significant, and we can infer that there are **signs of a clustering relationship between Airbnb Listings and Hotels**.

#### Relationship of Airbnb Listings and Tourist Attractions: Cross K graph 

```{r}
Airbnb_Tourism_Kcross <- Kcross(combined_central_ppp,
                           i="Airbnb", j="Tourism",
                           correction='border')
plot(Airbnb_Tourism_Kcross, xlim=c(0,1000))
```

The plot above reveals that majority of the Airbnb listings and Tourist Attractions are **not spatially independent**.

Only for distances around 180m, spatial independence for that distance is statistically NOT significant.

For distances less than 180m, the graph reveals **statistically significant clustering spatial pattern**.

Meanwhile, for distances more than ~185m, the graph reveals **statistically significant regular (inhibition) spatial pattern**.

However, we will do a hypothesis test to confirm this observation.

#### Relationship of Airbnb Listings and Tourist Attractions: Complete Spatial Randomness (CSR) statistical testing 

The test hypotheses are as follows:

Ho = The distribution of Airbnb Listings and Tourist Attractions are spatially independent.

H1 = The distribution of Airbnb Listings and Tourist Attractions are NOT spatially independent.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001 (i.e. at 99.9% confident interval).

```{r eval=FALSE}
Airbnb_Tourism_Kcross.csr <- envelope(combined_central_ppp, Kcross, i="Airbnb", j="Tourism", correction='border', nsim=999)
```

```{r echo=FALSE}
Airbnb_Tourism_Kcross.csr <- read_rds("the2data/rds/Airbnb_Tourism_Kcross.csr.rds")
```

```{r}
plot(Airbnb_Tourism_Kcross.csr, xlab="distance(m)", xlim=c(0,500))
```

The plot above reveals that the distribution of Airbnb Listings and Tourist Attractions are not spatially independent. Although part of the observed (black) line did fall into the envelope around 180m (same results as earlier), the majority of the observed line is not within the envelope of the 99.9% confidence interval, therefore the null hypothesis is rejected.

Same results as the earlier plot:

- For distances less than 180m, the graph reveals **statistically significant clustering spatial pattern**.

- Meanwhile, for distances more than ~185m, the graph reveals **statistically significant dispersion spatial pattern**.

In essence, we will reject the null hypothesis because the results are statistically significant, and we can infer that there are **signs of a clustering relationship between Airbnb Listings and Tourist Attractions for smaller distances (<180m)** and **signs of a regular (inhibition) relationship between Airbnb Listings and Tourist Attractions for larger distances (>185m)**, only distances around 180m are not statistically significant.

#### Relationship of Airbnb Listings and Hawker Centres: Cross K graph 

```{r}
Airbnb_Hawker_Kcross <- Kcross(combined_central_ppp,
                           i="Airbnb", j="Hawker",
                           correction='border')
plot(Airbnb_Hawker_Kcross, xlim=c(0,1000))
```

The plot above reveals that from around 150m and further, the Airbnb listings and Hawker Centres are **not spatially independent**. However, we will do a hypothesis test to confirm this observation.

#### Relationship of Airbnb Listings and Hawker Centres: Complete Spatial Randomness (CSR) statistical testing 

The test hypotheses are as follows:

Ho = The distribution of Airbnb Listings and Hawker Centres are spatially independent.

H1 = The distribution of Airbnb Listings and Hawker Centres are NOT spatially independent.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001 (i.e. at 99.9% confident interval).

In order to perform the CSR test, the *envelope()* of **spatstat** package will be used.

```{r eval=FALSE}
Airbnb_Hawker_Kcross.csr <- envelope(combined_central_ppp, Kcross, i="Airbnb", j="Hawker", correction='border', nsim=999)
```

```{r echo=FALSE}
Airbnb_Hawker_Kcross.csr <- read_rds("the2data/rds/Airbnb_Hawker_Kcross.csr.rds")
```

```{r}
plot(Airbnb_Hawker_Kcross.csr, xlab="distance(m)", xlim=c(0,500))
```
Similar to the results earlier on, only for distances 100m and below, the results are not satistiscally significant, so they are spatially independent.

However for the majority (>100m), the plot above reveals that the distribution of Airbnb Listings and Hawker Centres are not spatially independent. Since the observed(black) line is outside the envelope except for smaller distances (<100m), the null hypothesis is rejected because the empirical k-cross line is not within the envelope of the 99.9% confidence interval. 

In essence, we will reject the null hypothesis because the results are statistically significant, and we can infer that there are **signs of a clustering relationship between Airbnb Listings and Hawker Centres for distances larger than 100m**.

### 4.2.3 Analysing Spatial Point Process: Cross L-Function

Similar to Cross-K-Function, we can perform the CSR test by using *envelope()* of **spatstat** package will be used. L Function is used so as to normalise the results of K Function, and ensure higher accuracy of final results.

```{r fig.width=12, fig.height=8}
Airbnb_Hotels_Lcross <- Lcross(combined_central_ppp, i="Airbnb", j="Hotels", correction='border')
Airbnb_Tourism_Lcross <- Lcross(combined_central_ppp, i="Airbnb", j="Tourism", correction='border')
Airbnb_Hawker_Lcross <- Lcross(combined_central_ppp, i="Airbnb", j="Hawker", correction='border')

par(mfrow=c(2,2))
plot(Airbnb_Hotels_Lcross , . -r ~ r, xlab = "distance(m)", xlim=c(0, 500))
plot(Airbnb_Tourism_Lcross, . -r ~ r, xlab = "distance(m)", xlim=c(0, 500))
plot(Airbnb_Hawker_Lcross, . -r ~ r, xlab = "distance(m)", xlim=c(0, 500))
```

#### Relationship of Airbnb Listings and Location Factors: Complete Spatial Randomness (CSR) statistical testing

```{r eval=FALSE}
Hotels_Lcross.csr <- envelope(combined_central_ppp, Lcross, i="Airbnb", j="Hotels", correction='border', nsim=999)
Tourism_Lcross.csr <- envelope(combined_central_ppp, Lcross, i="Airbnb", j="Tourism", correction='border', nsim=999)
Hawker_Lcross.csr <- envelope(combined_central_ppp, Lcross, i="Airbnb", j="Hawker", correction='border', nsim=999)
```

```{r echo=FALSE}
Hotels_Lcross.csr <- read_rds("the2data/rds/Airbnb_Hotels_Lcross.csr.rds")
Tourism_Lcross.csr <- read_rds("the2data/rds/Airbnb_Tourism_Lcross.csr.rds")
Hawker_Lcross.csr <- read_rds("the2data/rds/Airbnb_Hawker_Lcross.csr.rds")
```

```{r fig.width=12, fig.height=8}
par(mfrow=c(2,2))
plot(Hotels_Lcross.csr, . -r ~ r, xlab="distance(m)", xlim=c(0,500))
plot(Tourism_Lcross.csr, . -r ~ r, xlab="distance(m)", xlim=c(0,500))
plot(Hawker_Lcross.csr, . -r ~ r, xlab="distance(m)", xlim=c(0,500))
```

The above results is in line with the earlier results obtained from Cross K Function, the null hypotheses for the respective factors are rejected, and this further strengthens our statistical conclusions.

Essentially:

- **Hotels:** We can infer that there are **signs of a clustering relationship between Airbnb Listings and Hotels**
- **Tourist Attractions:** We can infer that there are **signs of a clustering relationship between Airbnb Listings and Tourist Attractions for smaller distances (<180m)** and **signs of a regular relationship (inhibition) between Airbnb Listings and Tourist Attractions for larger distances (>185m)**, only distances around 180m are not statistically significant
- **Hawker Centres:** We can infer that there are **signs of a clustering relationship between Airbnb Listings and Hawker Centres for distances larger than 100m**

# 5. Section B: Impact of COVID-19 on Distribution of Airbnb Listings in 2021

In this section, we will analyse the impact of COVID-19 on Airbnb listings in Singapore, by comparing their listings data from both June 2019 and June 2021. This is why we also imported the 2021 dataset earlier on in **3. Data Wrangling ** section. 

## 5.1 Exploratory Spatial Data Analysis

### 5.1.1 Data preparation for Airbnb data subsets based on room type

We will do this for both 2019 and 2021 datasets. 

The 4 types of room types are:

- Entire home/apt
- Hotel room
- Private room
- Shared room

However, the 2019 dataset does not have **Hotel room** room type so we will exclude that room type from our analysis.

```{r}
EH2019 <- airbnb_2019[airbnb_2019$room_type == "Entire home/apt", ]
PR2019 <- airbnb_2019[airbnb_2019$room_type == "Private room", ]
SR2019 <- airbnb_2019[airbnb_2019$room_type == "Shared room", ]

EH2021 <- airbnb_2021[airbnb_2021$room_type == "Entire home/apt", ]
PR2021 <- airbnb_2021[airbnb_2021$room_type == "Private room", ]
SR2021 <- airbnb_2021[airbnb_2021$room_type == "Shared room", ]
```

#### Converting the subset dataframes into generic sp objects

Similar to what we did in *3. Data Wrangling*, we will need to convert the imported data frames into generic sp objects.

```{r}
EH2019_sp = as(as_Spatial(EH2019), "SpatialPoints")
PR2019_sp = as(as_Spatial(PR2019), "SpatialPoints")
SR2019_sp = as(as_Spatial(SR2019), "SpatialPoints")

EH2021_sp = as(as_Spatial(EH2021), "SpatialPoints")
PR2021_sp = as(as_Spatial(PR2021), "SpatialPoints")
SR2021_sp = as(as_Spatial(SR2021), "SpatialPoints")
```

#### Converting generic sp objects into ppp objects

Then, we will need convert the generic sp objects into ppp objects.

```{r}
EH2019_sp_ppp = as(EH2019_sp, "ppp")
PR2019_sp_ppp = as(PR2019_sp, "ppp")
SR2019_sp_ppp = as(SR2019_sp, "ppp")

EH2021_sp_ppp = as(EH2021_sp, "ppp")
PR2021_sp_ppp = as(PR2021_sp, "ppp")
SR2021_sp_ppp = as(SR2021_sp, "ppp")
```

#### Removing duplicate points from the pp objects

We will then use the jitter method to remove duplicate points.

```{r}
EH2019_sp_ppp_jit = rjitter(EH2019_sp_ppp, retry=TRUE, nsim=1, drop=TRUE)
PR2019_sp_ppp_jit = rjitter(PR2019_sp_ppp, retry=TRUE, nsim=1, drop=TRUE)
SR2019_sp_ppp_jit = rjitter(SR2019_sp_ppp, retry=TRUE, nsim=1, drop=TRUE)

EH2021_sp_ppp_jit = rjitter(EH2021_sp_ppp, retry=TRUE, nsim=1, drop=TRUE)
PR2021_sp_ppp_jit = rjitter(PR2021_sp_ppp, retry=TRUE, nsim=1, drop=TRUE)
SR2021_sp_ppp_jit = rjitter(SR2021_sp_ppp, retry=TRUE, nsim=1, drop=TRUE)
```

#### Rescale the unit of measurement from Metre to Kilometre

Rescaling is essential for getting more concrete kernel density values.

```{r}
EH2019_sp_ppp_jit.km = rescale(EH2019_sp_ppp_jit[sg_owin], 1000, "km")
PR2019_sp_ppp_jit.km = rescale(PR2019_sp_ppp_jit[sg_owin], 1000, "km")
SR2019_sp_ppp_jit.km = rescale(SR2019_sp_ppp_jit[sg_owin], 1000, "km")

EH2021_sp_ppp_jit.km = rescale(EH2021_sp_ppp_jit[sg_owin], 1000, "km")
PR2021_sp_ppp_jit.km = rescale(PR2021_sp_ppp_jit[sg_owin], 1000, "km")
SR2021_sp_ppp_jit.km = rescale(SR2021_sp_ppp_jit[sg_owin], 1000, "km")
```

### 5.1.2 Computing kernel density values  

```{r}
KDE_EH2019_bw <- density(EH2019_sp_ppp_jit.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
KDE_PR2019_bw <- density(PR2019_sp_ppp_jit.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
KDE_SR2019_bw <- density(SR2019_sp_ppp_jit.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")

KDE_EH2021_bw <- density(EH2021_sp_ppp_jit.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
KDE_PR2021_bw <- density(PR2021_sp_ppp_jit.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
KDE_SR2021_bw <- density(SR2021_sp_ppp_jit.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
```

```{r fig.width=8, fig.height=6}
par(mfrow=c(2,3))

plot(KDE_EH2019_bw, main="Entire Home/Apt 2019")
plot(KDE_PR2019_bw, main="Private Room 2019")
plot(KDE_SR2019_bw, main="Shared Room 2019")
plot(KDE_EH2021_bw, main="Entire Home/Apt 2021")
plot(KDE_PR2021_bw, main="Private Room 2021")
plot(KDE_SR2021_bw, main="Shared Room 2021")

```

From the results above, we can see that we didn't get substantial results by using **sigma = bw.diggle**. Therefore, we will use **sigma = 1.2** as the maximum bandwidth as ~1.2 or 1200 is the largest value, and hopefully we will get more comprehensive results.

```{r}
KDE_EH2019_bw <- density(EH2019_sp_ppp_jit.km, sigma=1.2, edge=TRUE, kernel="gaussian")
KDE_PR2019_bw <- density(PR2019_sp_ppp_jit.km, sigma=1.2, edge=TRUE, kernel="gaussian")
KDE_SR2019_bw <- density(SR2019_sp_ppp_jit.km, sigma=1.2, edge=TRUE, kernel="gaussian")

KDE_EH2021_bw <- density(EH2021_sp_ppp_jit.km, sigma=1.2, edge=TRUE, kernel="gaussian")
KDE_PR2021_bw <- density(PR2021_sp_ppp_jit.km, sigma=1.2, edge=TRUE, kernel="gaussian")
KDE_SR2021_bw <- density(SR2021_sp_ppp_jit.km, sigma=1.2, edge=TRUE, kernel="gaussian")
```

```{r fig.width=8, fig.height=6}
par(mfrow=c(2,3))

plot(KDE_EH2019_bw, main="Entire Home/Apt 2019")
plot(KDE_PR2019_bw, main="Private Room 2019")
plot(KDE_SR2019_bw, main="Shared Room 2019")
plot(KDE_EH2021_bw, main="Entire Home/Apt 2021")
plot(KDE_PR2021_bw, main="Private Room 2021")
plot(KDE_SR2021_bw, main="Shared Room 2021")
```

Voila! Now we have better results, so we shall proceed on. 

#### Converting KDE outputs into grid objects

This conversion into grid objects does not change the output results, it just makes it more suitable for mapping purposes.

```{r}
gridded_KDE_EH2019_bw <- as.SpatialGridDataFrame.im(KDE_EH2019_bw)
gridded_KDE_PR2019_bw <- as.SpatialGridDataFrame.im(KDE_PR2019_bw)
gridded_KDE_SR2019_bw <- as.SpatialGridDataFrame.im(KDE_SR2019_bw)

gridded_KDE_EH2021_bw <- as.SpatialGridDataFrame.im(KDE_EH2021_bw)
gridded_KDE_PR2021_bw <- as.SpatialGridDataFrame.im(KDE_PR2021_bw)
gridded_KDE_SR2021_bw <- as.SpatialGridDataFrame.im(KDE_SR2021_bw)
```

#### Converting Gridded outputs into Raster

Next, we will convert the gridded kernel density objects into RasterLayer object by using *raster()* of **raster** package.

```{r}
gridded_KDE_EH2019_raster <- raster(gridded_KDE_EH2019_bw)
gridded_KDE_PR2019_raster <- raster(gridded_KDE_PR2019_bw)
gridded_KDE_SR2019_raster <- raster(gridded_KDE_SR2019_bw)

gridded_KDE_EH2021_raster <- raster(gridded_KDE_EH2021_bw)
gridded_KDE_PR2021_raster <- raster(gridded_KDE_PR2021_bw)
gridded_KDE_SR2021_raster <- raster(gridded_KDE_SR2021_bw)
```

We then need to reassign the projected systems to the new Raster layer, because the crs will be lost (as shown in **3. Data Wrangling**) when converting into a ppp object earlier on. 

The below code chunk will assign the projected systems to the Raster layer.

```{r}
projection(gridded_KDE_EH2019_raster) <- CRS("+init=EPSG:3414 +datum=WGS84 +units=km")
projection(gridded_KDE_PR2019_raster) <- CRS("+init=EPSG:3414 +datum=WGS84 +units=km")
projection(gridded_KDE_SR2019_raster) <- CRS("+init=EPSG:3414 +datum=WGS84 +units=km")

projection(gridded_KDE_EH2021_raster) <- CRS("+init=EPSG:3414 +datum=WGS84 +units=km")
projection(gridded_KDE_PR2021_raster) <- CRS("+init=EPSG:3414 +datum=WGS84 +units=km")
projection(gridded_KDE_SR2021_raster) <- CRS("+init=EPSG:3414 +datum=WGS84 +units=km")
```

Finally, we can then plot the processed data into cartographic quality maps using **tmap** package.

### 5.1.3 Computing kernel density maps 

*P.S. Similar to the earlier kernel density maps, to avoid facing issues with deploying the study to Netlify, only one leaflet/interactive map will be utilised (the first map). The other maps will be shown as screenshots instead, however this should not affect the analysis as they are visually effective as well. *

#### Kernel Density of room type (Entire Home/Apt)

```{r, figures-side, fig.show="hold", out.width="50%"}
tmap_mode("view")

EH2019_map <- tm_shape(sg) +
  tm_borders(col = 'black',
             lwd = 1,
             alpha = 0.5) +
tm_shape(gridded_KDE_EH2019_raster) + 
  tm_raster("v", breaks=c(0, 20, 40, 60, 80, 100), alpha = 0.7) +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE, title = "Entire Home/Apt 2019") +
  tm_basemap('OpenStreetMap')

EH2021_map <- tm_shape(sg) +
  tm_borders(col = 'black',
             lwd = 1,
             alpha = 0.5) +
tm_shape(gridded_KDE_EH2021_raster) + 
  tm_raster("v", breaks=c(0, 20, 40, 60, 80, 100), alpha = 0.7) +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE, title = "Entire Home/Apt 2021") +
  tm_basemap('OpenStreetMap')

EH2019_map

EH2021_map
```

*P.S. For the above maps, I'm having difficulties plotting them side by side when deploying them onto Netlify. Therefore, this is the best that I can display, the Top Map will be for 2019 and the Bottom Map will be for 2021.*

#### Kernel Density of room type (Private Room)

```{r eval=FALSE}
tmap_mode("view")

PR2019_map <- tm_shape(sg) +
  tm_borders(col = 'black',
             lwd = 1,
             alpha = 0.5) +
tm_shape(gridded_KDE_PR2019_raster) + 
  tm_raster("v", breaks=c(0, 20, 40, 60, 80), alpha = 0.7) +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE, title = "Private Room 2019") +
  tm_basemap('OpenStreetMap')

PR2021_map <- tm_shape(sg) +
  tm_borders(col = 'black',
             lwd = 1,
             alpha = 0.5) +
tm_shape(gridded_KDE_PR2021_raster) + 
  tm_raster("v",breaks=c(0, 20, 40, 60, 80), alpha = 0.7) +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE, title = "Private Room 2021") +
  tm_basemap('OpenStreetMap')

tmap_arrange(PR2019_map, PR2021_map, asp=1, ncol=2)
```
![Screenshot of Kernel Density Maps of Private Room 2019 vs Private Room 2021](PR20192021.png)

#### Kernel Density of room type (Shared Room)

```{r eval=FALSE}
tmap_mode("view")

SR2019_map <- tm_shape(sg) +
  tm_borders(col = 'black',
             lwd = 1,
             alpha = 0.5) +
tm_shape(gridded_KDE_SR2019_raster) + 
  tm_raster("v", breaks=c(0, 5, 10, 15, 20, 25), alpha = 0.7) +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE, title = "Shared Room 2019") +
  tm_basemap('OpenStreetMap')

SR2021_map <- tm_shape(sg) +
  tm_borders(col = 'black',
             lwd = 1,
             alpha = 0.5) +
tm_shape(gridded_KDE_SR2021_raster) + 
  tm_raster("v", breaks=c(0, 5, 10, 15, 20, 25), alpha = 0.7) +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE, title = "Shared Room 2021") +
  tm_basemap('OpenStreetMap')

tmap_arrange(SR2019_map, SR2021_map, asp=1, ncol=2)
```
![Screenshot of Kernel Density Maps of Shared Room 2019 vs Shared Room 2021](SR20192021.png)

From the plotted maps above, we can see that for all 3 Room Types, it is evident that there has been a drop in the number of units per km square from 2019 to 2021. This could be seen explicitly through the lighter greens in the 2021 maps as compared to their 2019 counterparts.

This serves as evidence on how much COVID-19 has impacted these listings in Singapore, especially in a negative way. This is not surprising as there has been several news on the negative impact of COVID-19 on Airbnb, such as the organisation [Airbnb itself losing a 19 percent drop in revenue.](https://www.theverge.com/2020/11/16/21570416/airbnb-coronavirus-pandemic-travel-hospitality)

## 5.2 Second-order Spatial Point Patterns Analysis

### 5.2.1 Data Preparation

Using the code chunk below, we will combine the room types into one data frame respectively using their 2019 and 2021 data sets.

```{r}
C_EH2019 <- EH2019 %>%
  select("name", "geometry")

C_EH2019$Type <- "2019"

C_EH2021 <- EH2021 %>%
  select("name", "geometry") 

C_EH2021$Type <- "2021"

COMBINED_EH <- rbind(C_EH2019, C_EH2021)

C_PR2019 <- PR2019 %>%
  select("name", "geometry")

C_PR2019$Type <- "2019"

C_PR2021 <- PR2021 %>%
  select("name", "geometry") 

C_PR2021$Type <- "2021"

COMBINED_PR <- rbind(C_PR2019, C_PR2021)

C_SR2019 <- SR2019 %>%
  select("name", "geometry")

C_SR2019$Type <- "2019"

C_SR2021 <- SR2021 %>%
  select("name", "geometry") 

C_SR2021$Type <- "2021"

COMBINED_SR <- rbind(C_SR2019, C_SR2021)
```

The following code chunk will then change the respective data frames into Spatial Point Data Frames, then change the *Type* field from *character* data type to *factor* data type.

The next conversion will be converting into a PPP object which is required by **spatstat** package, and using the *jitter()* method to remove duplicates from the PPP object.

We will also scope down the study region to the **Central Region** similar to earlier on, therefore we wil use **central_owin** object to clip the boundary.

#### Conversion for Entire Home/Apt room type

```{r}
EH_combined_sp <- as(as_Spatial(COMBINED_EH), "SpatialPointsDataFrame")

EH_combined_sp@data$Type <- as.factor(EH_combined_sp@data$Type)

EH_combined_ppp <- as(EH_combined_sp, "ppp")

EH_combined_ppp_jit <- rjitter(EH_combined_ppp, retry = TRUE, nsim = 1, drop = TRUE)

EH_combined_central_ppp = EH_combined_ppp_jit[central_owin]

marks(EH_combined_central_ppp) <- factor(EH_combined_central_ppp$marks$Type)
```

#### Conversion for Private Room room type

```{r}
PR_combined_sp <- as(as_Spatial(COMBINED_PR), "SpatialPointsDataFrame")

PR_combined_sp@data$Type <- as.factor(PR_combined_sp@data$Type)

PR_combined_ppp <- as(PR_combined_sp, "ppp")

PR_combined_ppp_jit <- rjitter(PR_combined_ppp, retry = TRUE, nsim = 1, drop = TRUE)

PR_combined_central_ppp = PR_combined_ppp_jit[central_owin]

marks(PR_combined_central_ppp) <- factor(PR_combined_central_ppp$marks$Type)
```

#### Conversion for Shared Room room type

```{r}
SR_combined_sp <- as(as_Spatial(COMBINED_SR), "SpatialPointsDataFrame")

SR_combined_sp@data$Type <- as.factor(SR_combined_sp@data$Type)

SR_combined_ppp <- as(SR_combined_sp, "ppp")

SR_combined_ppp_jit <- rjitter(SR_combined_ppp, retry = TRUE, nsim = 1, drop = TRUE)

SR_combined_central_ppp = SR_combined_ppp_jit[central_owin]

marks(SR_combined_central_ppp) <- factor(SR_combined_central_ppp$marks$Type)
```

#### Analysing marked point patterns

Using the code chunk below, *density()* will be used to compute the kernel density for the respective objects. Then, *plot()* is used to plot the output kernel density objects derived.

##### Entire Home/Apt room type

```{r}
plot(density(split(rescale(EH_combined_central_ppp, 1000))))
```

Then, we will use *intensity()* of **spatstat** package is used to reveal the density of **Entire Home/Apt 2019 vs Entire Home/Apt 2021** as shown in the code chunk below.

```{r}
intensity(rescale(EH_combined_central_ppp, 1000))
```

The output reveals that for **Entire Home/Apt room type in the Central Region** study area:

- In **2019**, there were **28.41 Airbnb units** per km square
- In **2021**, there was a significant drop, with only **11.7 units** per km square

##### Private Room room type

```{r}
plot(density(split(rescale(PR_combined_central_ppp, 1000))))
```

Then, we will use *intensity()* of **spatstat** package is used to reveal the density of **Private Room 2019 vs Private Room 2021** as shown in the code chunk below.

```{r}
intensity(rescale(PR_combined_central_ppp, 1000))
```

The output reveals that for **Private Room room type in the Central Region** study area:

- In **2019**, there were **17.6 Airbnb units** per km square
- In **2021**, there was a significant drop as well, with only **10.6 units** per km square

##### Shared Room room type

```{r}
plot(density(split(rescale(SR_combined_central_ppp, 1000))))
```

Then, we will use *intensity()* of **spatstat** package is used to reveal the density of **Shared Room 2019 vs Shared Room 2021** as shown in the code chunk below.

```{r}
intensity(rescale(SR_combined_central_ppp, 1000))
```

The output reveals that for **Shared Room room type in the Central Region** study area:

- In **2019**, there were **2.89 Airbnb units** per km square
- In **2021**, there was a drop as well, with **1.06 units** per km square

### 5.2.2 Nearest Neighbour Index for Central Region using Clark-Evans test of aggregation

In this section, we will perform the Clark-Evans test of aggregation for a spatial point pattern by using *clarkevans.test()* of **statspat**. Earlier on we did the test for Airbnb 2019 data set, now we will conduct the test for **Airbnb 2021 data set** and compare the outputs of both tests.

- Data Preparation for Airbnb 2021 dataset. The same sets of conversions as the earlier processes will take place (changing into ppp object etc). 

```{r}
airbnb_2021_sp <- as_Spatial(airbnb_2021)
airbnb_2021_sp <- as(airbnb_2021_sp, "SpatialPoints")
airbnb_2021_ppp <- as(airbnb_2021_sp, "ppp")
airbnb2021_ppp_jit <- rjitter(airbnb_2021_ppp, retry = TRUE, nsim = 1, drop = TRUE)
airbnb_2021_ppp = airbnb2021_ppp_jit[sg_owin]
airbnb2021_central_ppp = airbnb_2021_ppp[central_owin]
```

The test hypotheses are:

Ho = The distribution of Airbnb Listings (2021) in the Central Region are randomly distributed.

H1 = The distribution of Airbnb Listings (2021) in the Central Region are not randomly distributed.

The 95% confident interval will be used. The null hypothesis will be rejected if p-value is smaller than alpha value of 0.05.

```{r eval=FALSE}
clarkevans.test(airbnb2021_central_ppp,
                correction='none',
                clipregion = NULL,
                alternative=c("two.sided"),
                nsim=999)
```
![](clarkevans2021.png)

As shown by the output above, the p-value is smaller than 0.05. Therefore, we will reject the null hypothesis that the Airbnb Listings (2021) are randomly distributed, meaning the spatial patterns are statistically significant and does show signs of clustering. 

However, what we are more interested in is the index values of this test. We will compare the respective indexes of the Airbnb 2019 and Airbnb 2021 data sets. 

![](clarkevans.png)
The above image shows the index of the **Airbnb 2019** data set, which is **0.4844.** Its **2021 counterpart** has an **index of 0.45007**, this enables us to infer that the Airbnb 2021 listings actually has a **more clustered spatial pattern** as compared to the 2019 data set. This is because the closer an index is to 0, the more clustered it is.

Essentially, a more clustered spatial pattern means that there are **a considerable greater number of Airbnb listings in 2021** as compared to previously in 2019, meaning that **COVID-19 did not affect the number of Airbnb listings in the study area negatively**.

This is unexpected as it contradicts what we could see from the kernel density values earlier on. Therefore, additional statistical testing will be done in the next section to evaluate this conclusion.

### 5.2.3 Analysing Spatial Point Process: G-Function

To further confirm our observations as stated above, the G function metric will be used for statistical testing. Using the G-function, we can then measure how are the Airbnb listings spaced, according to their respective years (2019 vs 2021). 

*Gest()* and *envelope* of **spatstat** package will be used to compute the metric.

#### Separating the three room types into 2019 and 2021 

```{r}
EH_ppp_2019 <- subset(EH_combined_central_ppp, marks == "2019")
EH_ppp_2021 <- subset(EH_combined_central_ppp, marks == "2021")

PR_ppp_2019 <- subset(PR_combined_central_ppp, marks == "2019")
PR_ppp_2021 <- subset(PR_combined_central_ppp, marks == "2021")

SR_ppp_2019 <- subset(SR_combined_central_ppp, marks == "2019")
SR_ppp_2021 <- subset(SR_combined_central_ppp, marks == "2021")
```

#### Plotting the G-function estimates and shapes for the three room types for 2019 and 2021 

```{r fig.width=12, fig.height=12}
G_EH_2019 <- Gest(EH_ppp_2019, correction = "border")
G_EH_2021 <- Gest(EH_ppp_2021, correction = "border")

G_PR_2019 <- Gest(PR_ppp_2019, correction = "border")
G_PR_2021 <- Gest(PR_ppp_2021, correction = "border")

G_SR_2019 <- Gest(SR_ppp_2019, correction = "border")
G_SR_2021 <- Gest(SR_ppp_2021, correction = "border")

par(mfrow=c(3,2))
plot(G_EH_2019, main="Airbnb Listings 2019 (Entire Home/Apt)", xlim=c(0,200))
plot(G_EH_2021, main="Airbnb Listings 2021 (Entire Home/Apt)", xlim=c(0,200))
plot(G_PR_2019, main="Airbnb Listings 2019 (Private Room)", xlim=c(0,200))
plot(G_PR_2021, main="Airbnb Listings 2021 (Private Room)", xlim=c(0,200))
plot(G_SR_2019, main="Airbnb Listings 2019 (Shared Room)", xlim=c(0,200))
plot(G_SR_2021, main="Airbnb Listings 2021 (Shared Room)", xlim=c(0,200))
```

#### Performing Complete Spatial Randomness Test

The hypotheses and test are as follows:

Ho = The distribution of Airbnb listings 2019/2021 are randomly distributed.

H1 = The distribution of Airbnb listings 2019/2021 are NOT randomly distributed.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001 (the value 0.001 is dependent on the number of simulations performed).

#### Performing Monte Carlo simulations for Airbnb Listings 2019 and 2021 

```{r eval=FALSE}
G_EH_2019.csr <- envelope(EH_ppp_2019, Gest, nsim = 999)
G_EH_2021.csr <- envelope(EH_ppp_2021, Gest, nsim = 999)
G_PR_2019.csr <- envelope(PR_ppp_2019, Gest, nsim = 999)
G_PR_2021.csr <- envelope(PR_ppp_2021, Gest, nsim = 999)
G_SR_2019.csr <- envelope(SR_ppp_2019, Gest, nsim = 999)
G_SR_2021.csr <- envelope(SR_ppp_2021, Gest, nsim = 999)
```

```{r include=FALSE}
G_EH_2019.csr <- read_rds("the2data/rds/G_EH_2019.csr.rds")
G_EH_2021.csr <- read_rds("the2data/rds/G_EH_2021.csr.rds")
G_PR_2019.csr <- read_rds("the2data/rds/G_PR_2019.csr.rds")
G_PR_2021.csr <- read_rds("the2data/rds/G_PR_2021.csr.rds")
G_SR_2019.csr <- read_rds("the2data/rds/G_SR_2019.csr.rds")
G_SR_2021.csr <- read_rds("the2data/rds/G_SR_2021.csr.rds")
```


```{r fig.width=12, fig.height=12}
par(mfrow=c(3,2))
plot(G_EH_2019.csr, main="Airbnb 2019 (Entire Home/Apt)", xlim=c(0,200))
plot(G_EH_2021.csr, main="Airbnb 2021 (Entire Home/Apt)", xlim=c(0,200))
plot(G_PR_2019.csr, main="Airbnb Listings 2019 (Private Room)", xlim=c(0,200))
plot(G_PR_2021.csr, main="Airbnb Listings 2021 (Private Room)", xlim=c(0,200))
plot(G_SR_2019.csr, main="Airbnb Listings 2019 (Shared Room)", xlim=c(0,200))
plot(G_SR_2021.csr, main="Airbnb Listings 2021 (Shared Room)", xlim=c(0,200))
```
For all three room types, both 2019 and 2021's observed(black) lines are outside the envelope. Therefore, we will **reject the null hypotheses** and infer that **clustering spatial patterns are statistically significant**. 

However, we are **more interested in comparing the shapes of 2019 against 2021**, so as to see whether there is a change in distribution due to the impact of COVID-19.

Essentially:

- **Entire Home/Apt:** The shape graph of 2019's rises more rapidly than its 2021 counterpart, therefore we can infer that **2019 actually has a more clustered spatial pattern than its 2021 counterpart** and that there were actually **significantly more Airbnb units back in 2019**.

- **Private Room:** Interestingly, the shape graph of 2021 has a slightly steeper rise as compared to 2019, therefore we could infer that for Private Room listings, there **could be more units in the area in 2021, resulting in a slightly more clustered spatial pattern as compared to 2019**.

- **Shared Room:** Similar to Entire Home/Apt room type, the shape graph of 2019's rises rapidly than its 2021 counterpart, therefore we can infer that **2019 actually has a more clustered spatial pattern than its 2021 counterpart** and that there were actually **significantly more Airbnb units back in 2019**.

On the whole, the two out of three room types has a 2019 shape graph that rises more rapidly than its 2021 counterpart, therefore we can infer that majority of the results shows that **2019 actually has a more clustered spatial pattern than its 2021 counterpart** and that there were actually **significantly more Airbnb units back in 2019**.

### 5.2.4 Analysing Spatial Point Process: F-Function

To further confirm our observations as stated above, **another round of statistical testing** will be done with the **F function** metric. Using the F-function, we can then estimate the number of pair point Airbnb listings 2019/2021 from the sample point locations that is chosen at random.

We will then **compare the final results against our results derived from the earlier G-function test**.

#### Plotting the F-function estimates and shapes for the three room types for 2019 and 2021 

The code chunk below will be used to compute F-function using *Fest()* of **spatat** package.

```{r fig.width=12, fig.height=12}
F_EH_2019 <- Fest(EH_ppp_2019)
F_EH_2021 <- Fest(EH_ppp_2021)

F_PR_2019 <- Fest(PR_ppp_2019)
F_PR_2021 <- Fest(PR_ppp_2021)

F_SR_2019 <- Fest(SR_ppp_2019)
F_SR_2021 <- Fest(SR_ppp_2021)

par(mfrow=c(3,2))
plot(F_EH_2019, main="Airbnb Listings 2019 (Entire Home/Apt)", xlim=c(0,200))
plot(F_EH_2021, main="Airbnb Listings 2021 (Entire Home/Apt)", xlim=c(0,200))
plot(F_PR_2019, main="Airbnb Listings 2019 (Private Room)", xlim=c(0,200))
plot(F_PR_2021, main="Airbnb Listings 2021 (Private Room)", xlim=c(0,200))
plot(F_SR_2019, main="Airbnb Listings 2019 (Shared Room)", xlim=c(0,200))
plot(F_SR_2021, main="Airbnb Listings 2021 (Shared Room)", xlim=c(0,200))
```

#### Performing Complete Spatial Randomness Test

The hypotheses and test are as follows:

Ho = The distribution of Airbnb listings 2019/2021 are randomly distributed.

H1 = The distribution of Airbnb listings 2019/2021 are NOT randomly distributed.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001 (the value 0.001 is dependent on the number of simulations performed).

#### Performing Monte Carlo simulations for Airbnb Listings 2019 and 2021 

```{r eval=FALSE}
F_EH_2019.csr <- envelope(EH_ppp_2019, Fest, nsim = 999)
F_EH_2021.csr <- envelope(EH_ppp_2021, Fest, nsim = 999)
F_PR_2019.csr <- envelope(PR_ppp_2019, Fest, nsim = 999)
F_PR_2021.csr <- envelope(PR_ppp_2021, Fest, nsim = 999)
F_SR_2019.csr <- envelope(SR_ppp_2019, Fest, nsim = 999)
F_SR_2021.csr <- envelope(SR_ppp_2021, Fest, nsim = 999)
```

```{r include=FALSE}
F_EH_2019.csr <- read_rds("the2data/rds/F_EH_2019.csr.rds")
F_EH_2021.csr <- read_rds("the2data/rds/F_EH_2021.csr.rds")
F_PR_2019.csr <- read_rds("the2data/rds/F_PR_2019.csr.rds")
F_PR_2021.csr <- read_rds("the2data/rds/F_PR_2021.csr.rds")
F_SR_2019.csr <- read_rds("the2data/rds/F_SR_2019.csr.rds")
F_SR_2021.csr <- read_rds("the2data/rds/F_SR_2021.csr.rds")
```

```{r fig.width=12, fig.height=12}
par(mfrow=c(3,2))
plot(F_EH_2019.csr, main="Airbnb 2019 (Entire Home/Apt)", xlim=c(0,500), ylim=c(0,0.8))
plot(F_EH_2021.csr, main="Airbnb 2021 (Entire Home/Apt)", xlim=c(0,500), ylim=c(0,0.8))
plot(F_PR_2019.csr, main="Airbnb Listings 2019 (Private Room)", xlim=c(0,500), ylim=c(0,0.8))
plot(F_PR_2021.csr, main="Airbnb Listings 2021 (Private Room)", xlim=c(0,500), ylim=c(0,0.8))
plot(F_SR_2019.csr, main="Airbnb Listings 2019 (Shared Room)", xlim=c(0,500), ylim=c(0,0.8))
plot(F_SR_2021.csr, main="Airbnb Listings 2021 (Shared Room)", xlim=c(0,500), ylim=c(0,0.8))
```
The results are in line with the previous G-function results. For all three room types, both 2019 and 2021's observed(black) lines are below the envelope. Therefore, we will **reject the null hypotheses** and infer that **clustering spatial patterns are statistically significant**. 

However again, the main focus is to **compare the shapes of 2019 against 2021**, so as to see whether there is a change in distribution due to the impact of COVID-19.

*P.S.* **Clustered** *= F(r) rises slowly at first, but more rapidly at longer distances.* **Evenness** *= F(r) rises rapidly at first, then slowly at longer distances.*

Essentially:

- **Entire Home/Apt:** The shape graph of 2021 rises slightly more rapidly at first than its 2021 counterpart, therefore we can infer that **2021 actually has a more even spatial pattern than its 2019 counterpart**. This is on target as the previous G-function results.

- **Private Room:** The shape graph of 2019 has a slightly steeper rise at the start as compared to 2021, therefore we could infer that for Private Room listings, there **could be more units in the area in 2021, resulting in a slightly more clustered spatial pattern as compared to 2019**. This is on target as the previous G-function results as well.

- **Shared Room:** The shape graph of 2019's rises slowly at first than its 2021 counterpart, then more rapidly as the distance becomes larger. Therefore we can infer that **2019 actually has a more clustered spatial pattern than its 2021 counterpart** and that there were actually **significantly more Airbnb units back in 2019**. This is on target as the previous G-function results as well.

# 6. Conclusion

### Section A: Distribution of Airbnb Listings in 2019

Based on our end results, **signs of clustering relationships between Airbnb Listings and the respective factors** (Hotels, Tourist Attractions, Hawker Centres) are **statistically significant**. 

### Section B: Impact of COVID-19 on Distribution of Airbnb Listings in 2021

On the whole, we can infer that majority of the statistical results shows that **2019 actually has a more clustered spatial pattern than its 2021 counterpart** and that there were actually **significantly more Airbnb units back in 2019**. This meant that COVID-19 did impacted the Airbnb Listings in Singapore, in a **negative way** because there were lesser number of listings in 2021 as compared to 2019.

The only exception was for **Private Room room type**, where the statistical testing did not correlate to its earlier spatial pattern observations derived from its kernel density values. 

However, these observations may not be conclusive due to several limitations such as limited data sources. Further analysis and study should be conducted in the future so as to further affirm the observation results.

### As A Whole

The location of **Airbnb listings** were found to be **NOT spatially independent**, and in the Study Area (Central Region), Airbnb listings were found to **cluster around (according to order); 1) Hotels, 2) Hawker Centres, 3) Tourist Attractions**.

Due to the emergence of COVID-19, the study also uncovered the negative impact on the distribution of Airbnb listings in Singapore; such as **lowering the number of Entire Home/Apt room type units per km square** from 2019 to 2021, with **28.41 to 11.7 units per km square** respectively for those years.

This is not surprising as the COVID-19 pandemic has caused [devastating economic consequences on a world-wide scale](https://www.bbc.com/news/business-51706225), however we must press on and learn to cohabit with the COVID-19 virus, then work together to achieve economic success for our country again. 

# 7. References

- [Short-term home sharing remains illegal in Singapore; Airbnb disappointed](https://www.todayonline.com/singapore/short-term-home-sharing-remains-illegal-singapore-airbnb-disappointed)

- [Kernel vs Point Density](https://community.esri.com/t5/arcgis-spatial-analyst-questions/kernel-vs-point-density/td-p/610486)

- [Understanding the Cross K Function](https://blog.jlevente.com/understanding-the-cross-k-function/)
